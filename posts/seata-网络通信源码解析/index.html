<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.148.1"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="He Jin"><meta property="og:url" content="https://blog.remind.me/posts/seata-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><link rel=canonical href=https://blog.remind.me/posts/seata-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/><link rel=apple-touch-icon href=/images/favicon.png><link rel=icon href=/images/favicon.png><link rel=shortcut href=/images/favicon.png><link rel=alternate type=application/atom+xml href=https://blog.remind.me/index.xml title="Hejin's Blog"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.remind.me\/"},"articleSection":"posts","name":"Seata 网络通信源码解析","headline":"Seata 网络通信源码解析","description":" 源码版本：2.5.0\n在 Seata 中有三类角色，TC、RM、TM，Seata Server 作为 TC 协调分支事务的提交和回滚，各个资源作为 RM 和 TM，那么这三者之间是如何通信的呢？相信读完这篇文章之后，你就会知道答案。\n整体类层次结构 我们先着眼大局，看一看 Seata 整个网络通信的类层次结构。\n从类结构层次分析可以看出，Seata 的网络通信底层基于 Netty 实现。AbstractNettyRemoting 作为整个通信层的核心抽象基类，封装了通用的 RPC 基础能力，例如同步调用 (sendSync) 和异步调用 (sendAsync) 等方法。\n本质上，网络通信的核心操作可归结为同步和异步两种调用模式，而请求与响应的区别主要在于报文内容的语义。\n虽然 AbstractNettyRemoting 提供了这些基础方法，但不同角色（Server、TM、RM）在调用行为上是存在差异的，比如 Server 的请求调用需要明确指定目标客户端进行消息发送，而 Client（TM\/RM）发送请求时通常无需指定特定的服务端实例。它们只需将请求发出，具体的服务端节点选择由实现类中的负载均衡机制完成。\n为了体现这种角色差异，Seata 设计了 RemotingServer 和 RemotingClient 两个接口。它们都依赖于 AbstractNettyRemoting 提供的底层网络通信能力，并由各自的具体子类继承 AbstractNettyRemoting 来实现相应的接口功能。\n如何启动 Server 和 Client 下面分别以 Server 和 Client 的视角来看它们是如何启动的，以及在启动的时候需要做些什么事情。\nServer 是怎么启动的 Seata Server 端作为一个独立的 SpringBoot 项目，要怎么样才能在 SpringBoot 启动的时候自动做点事呢？\nSeata 的做法是实现了 CommandLineRunner 接口，我们主要关注它的 run 方法：\n\/\/ org.apache.seata.server.ServerRunner#run public void run(String... args) { try { long start = System.currentTimeMillis(); seataServer.start(args); started = true; long cost = System.currentTimeMillis() - start; LOGGER.info(\u0026#34;\\r\\n you can visit seata console UI on namingserver. \\r\\n log path: {}.\u0026#34;, this.logPath); LOGGER.info(\u0026#34;seata server started in {} millSeconds\u0026#34;, cost); } catch (Throwable e) { started = Boolean.FALSE; LOGGER.error(\u0026#34;seata server start error: {} \u0026#34;, e.getMessage(), e); System.exit(-1); } } 这其中核心的逻辑就在 seataServer.start() 方法中：\n","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"2025","datePublished":"2025-07-21 00:00:00 \u002b0000 UTC","dateModified":"2025-07-21 00:00:00 \u002b0000 UTC","url":"https:\/\/blog.remind.me\/posts\/seata-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90\/","keywords":[]}</script><title>Seata 网络通信源码解析</title><meta property="og:title" content="Seata 网络通信源码解析"><meta property="og:type" content="article"><meta property="og:description" content=' 源码版本：2.5.0
在 Seata 中有三类角色，TC、RM、TM，Seata Server 作为 TC 协调分支事务的提交和回滚，各个资源作为 RM 和 TM，那么这三者之间是如何通信的呢？相信读完这篇文章之后，你就会知道答案。
整体类层次结构 我们先着眼大局，看一看 Seata 整个网络通信的类层次结构。
从类结构层次分析可以看出，Seata 的网络通信底层基于 Netty 实现。AbstractNettyRemoting 作为整个通信层的核心抽象基类，封装了通用的 RPC 基础能力，例如同步调用 (sendSync) 和异步调用 (sendAsync) 等方法。
本质上，网络通信的核心操作可归结为同步和异步两种调用模式，而请求与响应的区别主要在于报文内容的语义。
虽然 AbstractNettyRemoting 提供了这些基础方法，但不同角色（Server、TM、RM）在调用行为上是存在差异的，比如 Server 的请求调用需要明确指定目标客户端进行消息发送，而 Client（TM/RM）发送请求时通常无需指定特定的服务端实例。它们只需将请求发出，具体的服务端节点选择由实现类中的负载均衡机制完成。
为了体现这种角色差异，Seata 设计了 RemotingServer 和 RemotingClient 两个接口。它们都依赖于 AbstractNettyRemoting 提供的底层网络通信能力，并由各自的具体子类继承 AbstractNettyRemoting 来实现相应的接口功能。
如何启动 Server 和 Client 下面分别以 Server 和 Client 的视角来看它们是如何启动的，以及在启动的时候需要做些什么事情。
Server 是怎么启动的 Seata Server 端作为一个独立的 SpringBoot 项目，要怎么样才能在 SpringBoot 启动的时候自动做点事呢？
Seata 的做法是实现了 CommandLineRunner 接口，我们主要关注它的 run 方法：
// org.apache.seata.server.ServerRunner#run public void run(String... args) { try { long start = System.currentTimeMillis(); seataServer.start(args); started = true; long cost = System.currentTimeMillis() - start; LOGGER.info("\r\n you can visit seata console UI on namingserver. \r\n log path: {}.", this.logPath); LOGGER.info("seata server started in {} millSeconds", cost); } catch (Throwable e) { started = Boolean.FALSE; LOGGER.error("seata server start error: {} ", e.getMessage(), e); System.exit(-1); } } 这其中核心的逻辑就在 seataServer.start() 方法中：
'><meta name=description content=' 源码版本：2.5.0
在 Seata 中有三类角色，TC、RM、TM，Seata Server 作为 TC 协调分支事务的提交和回滚，各个资源作为 RM 和 TM，那么这三者之间是如何通信的呢？相信读完这篇文章之后，你就会知道答案。
整体类层次结构 我们先着眼大局，看一看 Seata 整个网络通信的类层次结构。
从类结构层次分析可以看出，Seata 的网络通信底层基于 Netty 实现。AbstractNettyRemoting 作为整个通信层的核心抽象基类，封装了通用的 RPC 基础能力，例如同步调用 (sendSync) 和异步调用 (sendAsync) 等方法。
本质上，网络通信的核心操作可归结为同步和异步两种调用模式，而请求与响应的区别主要在于报文内容的语义。
虽然 AbstractNettyRemoting 提供了这些基础方法，但不同角色（Server、TM、RM）在调用行为上是存在差异的，比如 Server 的请求调用需要明确指定目标客户端进行消息发送，而 Client（TM/RM）发送请求时通常无需指定特定的服务端实例。它们只需将请求发出，具体的服务端节点选择由实现类中的负载均衡机制完成。
为了体现这种角色差异，Seata 设计了 RemotingServer 和 RemotingClient 两个接口。它们都依赖于 AbstractNettyRemoting 提供的底层网络通信能力，并由各自的具体子类继承 AbstractNettyRemoting 来实现相应的接口功能。
如何启动 Server 和 Client 下面分别以 Server 和 Client 的视角来看它们是如何启动的，以及在启动的时候需要做些什么事情。
Server 是怎么启动的 Seata Server 端作为一个独立的 SpringBoot 项目，要怎么样才能在 SpringBoot 启动的时候自动做点事呢？
Seata 的做法是实现了 CommandLineRunner 接口，我们主要关注它的 run 方法：
// org.apache.seata.server.ServerRunner#run public void run(String... args) { try { long start = System.currentTimeMillis(); seataServer.start(args); started = true; long cost = System.currentTimeMillis() - start; LOGGER.info("\r\n you can visit seata console UI on namingserver. \r\n log path: {}.", this.logPath); LOGGER.info("seata server started in {} millSeconds", cost); } catch (Throwable e) { started = Boolean.FALSE; LOGGER.error("seata server start error: {} ", e.getMessage(), e); System.exit(-1); } } 这其中核心的逻辑就在 seataServer.start() 方法中：
'><meta property="og:locale" content="cn"><meta property="og:image" content="/images/favicon.png"><style>body{font-family:bree serif,sans-serif;-webkit-font-smoothing:antialiased;margin:0 20px}article{max-width:800px;margin-left:auto;margin-right:auto}a{color:#000;text-decoration:none}a:hover{font-weight:600;text-decoration:underline}.post-ads{margin:50px 0}.markdown-body{font-size:18px;max-width:100%}.markdown-body a{text-decoration:underline;text-decoration-color:#000}.markdown-body blockquote{margin:0;padding:0 1em;color:#57606a;border-left:.25em solid #d0d7de}.markdown-body pre{padding:8px 12px;overflow:auto;border-radius:6px;font-size:14px;line-height:1.4}.markdown-body code{padding:.2em .4em;font-size:85%;background-color:#f6f8fa;border-radius:6px}.markdown-body table{border-collapse:collapse;margin:25px 0;font-size:.9em;min-width:400px;border-radius:8px;overflow:hidden;box-shadow:0 2px 8px rgba(0,0,0,.1);width:100%}.markdown-body table thead tr{background-color:#2c3e50;color:#fff;text-align:left;font-weight:700}.markdown-body table th,.markdown-body table td{padding:12px 15px;border-bottom:1px solid #ddd}.markdown-body table tbody tr{border-bottom:1px solid #ddd}.markdown-body table tbody tr:nth-of-type(even){background-color:#f8f9fa}.markdown-body table tbody tr:last-of-type{border-bottom:2px solid #2c3e50}.markdown-body table tbody tr:hover{background-color:#e8f4f8;transition:background-color .3s ease}.markdown-body table th{position:relative;background-color:#34495e;color:#fff;font-weight:600;text-transform:uppercase;letter-spacing:.5px;font-size:.85em}.markdown-body table td{color:#333;line-height:1.6}@media screen and (max-width:768px){.markdown-body table{font-size:.8em;min-width:100%}.markdown-body table th,.markdown-body table td{padding:8px 10px}}.markdown-body .table-container{overflow-x:auto;overflow-y:hidden;margin:20px 0;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,.1);scrollbar-width:thin;scrollbar-color:#cbd5e0 #f7fafc}.markdown-body .table-container::-webkit-scrollbar{height:8px}.markdown-body .table-container::-webkit-scrollbar-track{background:#f7fafc;border-radius:4px}.markdown-body .table-container::-webkit-scrollbar-thumb{background:#cbd5e0;border-radius:4px}.markdown-body .table-container::-webkit-scrollbar-thumb:hover{background:#a0aec0}.markdown-body .table-container table{margin:0;min-width:100%;white-space:nowrap}.markdown-body .table-container table td,.markdown-body .table-container table th{white-space:nowrap;min-width:120px}.markdown-body .table-title{font-weight:600;color:#2c3e50;margin-bottom:10px;font-size:1.1em}.markdown-body .table-description{color:#666;font-size:.9em;margin-top:8px;font-style:italic}.markdown-body table td:first-child{font-weight:500;color:#2c3e50}.markdown-body table td{text-align:left}.markdown-body table a{color:#3498db;text-decoration:none;border-bottom:1px dotted #3498db}.markdown-body table a:hover{color:#2980b9;border-bottom-color:#2980b9}.markdown-body table strong{color:#e74c3c;font-weight:600}.markdown-body table{animation:fadeInTable .5s ease-in-out}@keyframes fadeInTable{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}.markdown-body pre>code{padding:0;font-size:100%;background-color:inherit;border:0}.Chinese .markdown-body{line-height:200%}.site-date-catalog{font-size:2rem}.header-title{font-size:2rem;font-weight:700;margin-top:32px;font-family:bungee shade,sans-serif}.header-title a{text-decoration:none}.header-subtitle{color:#666}.header-items{margin:10px 0}.header-item{margin:0 5px}.header-line{width:100%;border-width:2px;border-color:#482936;border-style:solid none none none}.lang-switch{font-weight:600}#posts-list{min-height:600px}.posts-line{font-size:1.2rem;margin:12px 0}.posts-categories{font-size:.8rem;margin:auto;text-align:center}.posts-category{padding:3px 0;border:#000 2px solid;border-radius:5px}.site-footer{margin-top:50px;padding:20px 0;border-top:2px solid #eee}.footer-content{display:flex;justify-content:center;align-items:center;flex-wrap:wrap;font-size:.9rem;color:#666}.footer-copyright{margin:0 8px}.footer-separator{margin:0 8px;color:#ccc}.footer-license{margin:0 8px}.footer-license a{color:#666;text-decoration:none;border-bottom:1px dotted #666}.footer-license a:hover{color:#000;border-bottom-color:#000;font-weight:400}.site-footer-item{margin-right:12px}.post-header{margin-bottom:50px}.post-title{font-size:2rem;font-weight:600}.post-tags{display:inline;font-weight:600;padding:2px 5px;margin-right:6px;border:#000 2px solid;border-radius:5px}.post-date{font-weight:800}.post-author{float:right;font-weight:600}.page-content{min-height:60%}.post-content{margin-bottom:50px}.post-content p{hyphens:auto;line-height:1.8;text-justify:ideographic;margin-bottom:1em}.post-content img{max-width:100%;display:block;margin-right:auto;margin-top:6px}.rounded-shadow-image{border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,8%),0 2px 4px rgba(0,0,0,5%);transition:transform .3s ease,box-shadow .3s ease;margin:20px auto}.rounded-shadow-image:hover{transform:translateY(-1px);box-shadow:0 6px 16px rgba(0,0,0,.12),0 3px 6px rgba(0,0,0,8%)}.post-content .post-gallery{display:flex;flex-wrap:wrap;gap:6px}.post-content .post-gallery img{margin-right:auto;margin-top:auto;width:calc(50% - 3px)}.related-content{border-width:3px;border-style:solid;border-color:#000;padding:0 10px;margin-bottom:50px;margin-top:100px}.related-content li{margin:5px 0}.taxonomy-term{font-size:3rem}.gallery-img{text-align:center}.gallery-img span{text-align:center}.gallery-img-desc{font-size:.8em;font-weight:800}.toc-container{position:fixed;top:50%;right:20px;transform:translateY(-50%);width:260px;max-height:70vh;background:#fff;border:2px solid #000;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,.1);z-index:1000;opacity:0;visibility:hidden;transition:all .3s ease;overflow:hidden;display:flex;flex-direction:column}.toc-container:hover{opacity:1;visibility:visible}.toc-container.show{opacity:1;visibility:visible}.toc-header{background:#000;color:#fff;padding:12px 16px;font-weight:600;font-size:14px;border-bottom:1px solid #eee;height:46px;box-sizing:border-box;flex-shrink:0}.toc-content{padding:16px 16px 20px;max-height:calc(70vh - 46px);overflow-y:auto;font-size:14px;line-height:1.4;box-sizing:border-box;flex:1}.toc-content::-webkit-scrollbar{width:4px}.toc-content::-webkit-scrollbar-track{background:#f1f1f1}.toc-content::-webkit-scrollbar-thumb{background:#ccc;border-radius:2px}.toc-content::-webkit-scrollbar-thumb:hover{background:#999}.toc-content ul{list-style:none;margin:0;padding:0}.toc-content li{margin:0;padding:0}.toc-content a{display:block;padding:6px 0;color:#333;text-decoration:none;border-left:2px solid transparent;padding-left:12px;transition:all .2s ease;word-wrap:break-word;overflow-wrap:break-word}.toc-content a:hover{color:#000;border-left-color:#000;background:#f8f9fa;font-weight:600;text-decoration:none}.toc-content a.active{color:#000;border-left-color:#000;background:#f0f0f0;font-weight:600}.toc-content .toc-h1 a{padding-left:12px;font-weight:600}.toc-content .toc-h2 a{padding-left:24px;font-size:13px}.toc-content .toc-h3 a{padding-left:36px;font-size:12px;color:#666}.toc-trigger{position:fixed;top:50%;right:0;width:30px;height:80px;transform:translateY(-50%);z-index:999;background:rgba(0,0,0,.1);border-radius:8px 0 0 8px;transition:background .3s ease}.toc-trigger:hover{background:rgba(0,0,0,.2)}@media screen and (max-width:1200px){.toc-container,.toc-trigger{display:none}}#disqus_thread{position:relative;margin-bottom:20px}.back-to-top{position:fixed;bottom:30px;right:10%;width:50px;height:50px;background-color:#fff;border:2px solid #000;border-radius:50%;cursor:pointer;display:none;justify-content:center;align-items:center;font-size:20px;font-weight:700;color:#000;text-decoration:none;transition:all .3s ease;z-index:1000;box-shadow:0 2px 8px rgba(0,0,0,.1)}.back-to-top:hover{background-color:#000;color:#fff;text-decoration:none;font-weight:700;transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,.2)}.back-to-top.show{display:flex}.back-to-top::before{content:"↑";font-size:24px;line-height:1}@media screen and (max-width:600px){.header-title,.header-subtitle,.header-items{}.posts-line{font-size:16px}.markdown-body{font-size:16px}.post-title{font-size:2rem}.post-content p{letter-spacing:.05em}.post-content .post-gallery img{width:100%}.rounded-shadow-image{border-radius:6px;box-shadow:0 2px 8px rgba(0,0,0,6%),0 1px 2px rgba(0,0,0,4%);margin:16px auto}.rounded-shadow-image:hover{transform:none;box-shadow:0 2px 8px rgba(0,0,0,6%),0 1px 2px rgba(0,0,0,4%)}.footer-content{flex-direction:column;text-align:center}.footer-separator{display:none}.footer-copyright,.footer-license{margin:4px 0}.back-to-top{bottom:20px;right:3%;width:45px;height:45px;font-size:18px}.back-to-top::before{font-size:20px}.markdown-body table{box-shadow:0 1px 4px rgba(0,0,0,8%);border-radius:6px}.markdown-body table th{font-size:.8em;padding:10px 8px}.markdown-body table td{font-size:.85em;padding:10px 8px}.markdown-body .table-container{-webkit-overflow-scrolling:touch;scroll-behavior:smooth}.markdown-body .table-container table td,.markdown-body .table-container table th{min-width:100px;padding:8px 6px}}@media screen and (max-width:48em){.posts-category{display:none}}</style><style>.container,.container-fluid{margin-right:auto;margin-left:auto}.container-fluid{padding-right:2rem;padding-left:2rem}.row{box-sizing:border-box;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:0;-ms-flex:0 1 auto;flex:initial;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-right:-.5rem;margin-left:-.5rem}.row.reverse{-webkit-box-orient:horizontal;-webkit-box-direction:reverse;-ms-flex-direction:row-reverse;flex-direction:row-reverse}.col.reverse{-webkit-box-orient:vertical;-webkit-box-direction:reverse;-ms-flex-direction:column-reverse;flex-direction:column-reverse}.col-xs,.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9,.col-xs-offset-0,.col-xs-offset-1,.col-xs-offset-10,.col-xs-offset-11,.col-xs-offset-12,.col-xs-offset-2,.col-xs-offset-3,.col-xs-offset-4,.col-xs-offset-5,.col-xs-offset-6,.col-xs-offset-7,.col-xs-offset-8,.col-xs-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-xs{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-xs-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-xs-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-xs-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-xs-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-xs-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-xs-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-xs-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-xs-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-xs-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-xs-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-xs-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-xs-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-xs-offset-0{margin-left:0}.col-xs-offset-1{margin-left:8.33333333%}.col-xs-offset-2{margin-left:16.66666667%}.col-xs-offset-3{margin-left:25%}.col-xs-offset-4{margin-left:33.33333333%}.col-xs-offset-5{margin-left:41.66666667%}.col-xs-offset-6{margin-left:50%}.col-xs-offset-7{margin-left:58.33333333%}.col-xs-offset-8{margin-left:66.66666667%}.col-xs-offset-9{margin-left:75%}.col-xs-offset-10{margin-left:83.33333333%}.col-xs-offset-11{margin-left:91.66666667%}.start-xs{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-xs{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-xs{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-xs{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-xs{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-xs{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-xs{-ms-flex-pack:distribute;justify-content:space-around}.between-xs{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-xs{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-xs{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}@media only screen and (min-width:48em){.container{width:49rem}.col-sm,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-sm-offset-0,.col-sm-offset-1,.col-sm-offset-10,.col-sm-offset-11,.col-sm-offset-12,.col-sm-offset-2,.col-sm-offset-3,.col-sm-offset-4,.col-sm-offset-5,.col-sm-offset-6,.col-sm-offset-7,.col-sm-offset-8,.col-sm-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-sm{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-sm-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-sm-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-sm-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-sm-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-sm-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-sm-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-sm-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-sm-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-sm-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-sm-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-sm-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-sm-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-sm-offset-0{margin-left:0}.col-sm-offset-1{margin-left:8.33333333%}.col-sm-offset-2{margin-left:16.66666667%}.col-sm-offset-3{margin-left:25%}.col-sm-offset-4{margin-left:33.33333333%}.col-sm-offset-5{margin-left:41.66666667%}.col-sm-offset-6{margin-left:50%}.col-sm-offset-7{margin-left:58.33333333%}.col-sm-offset-8{margin-left:66.66666667%}.col-sm-offset-9{margin-left:75%}.col-sm-offset-10{margin-left:83.33333333%}.col-sm-offset-11{margin-left:91.66666667%}.start-sm{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-sm{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-sm{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-sm{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-sm{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-sm{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-sm{-ms-flex-pack:distribute;justify-content:space-around}.between-sm{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-sm{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-sm{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:64em){.container{width:65rem}.col-md,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-md-offset-0,.col-md-offset-1,.col-md-offset-10,.col-md-offset-11,.col-md-offset-12,.col-md-offset-2,.col-md-offset-3,.col-md-offset-4,.col-md-offset-5,.col-md-offset-6,.col-md-offset-7,.col-md-offset-8,.col-md-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-md{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-md-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-md-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-md-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-md-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-md-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-md-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-md-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-md-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-md-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-md-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-md-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-md-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-md-offset-0{margin-left:0}.col-md-offset-1{margin-left:8.33333333%}.col-md-offset-2{margin-left:16.66666667%}.col-md-offset-3{margin-left:25%}.col-md-offset-4{margin-left:33.33333333%}.col-md-offset-5{margin-left:41.66666667%}.col-md-offset-6{margin-left:50%}.col-md-offset-7{margin-left:58.33333333%}.col-md-offset-8{margin-left:66.66666667%}.col-md-offset-9{margin-left:75%}.col-md-offset-10{margin-left:83.33333333%}.col-md-offset-11{margin-left:91.66666667%}.start-md{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-md{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-md{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-md{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-md{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-md{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-md{-ms-flex-pack:distribute;justify-content:space-around}.between-md{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-md{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-md{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:75em){.container{width:76rem}.col-lg,.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-lg-offset-0,.col-lg-offset-1,.col-lg-offset-10,.col-lg-offset-11,.col-lg-offset-12,.col-lg-offset-2,.col-lg-offset-3,.col-lg-offset-4,.col-lg-offset-5,.col-lg-offset-6,.col-lg-offset-7,.col-lg-offset-8,.col-lg-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-lg{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-lg-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-lg-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-lg-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-lg-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-lg-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-lg-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-lg-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-lg-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-lg-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-lg-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-lg-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-lg-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-lg-offset-0{margin-left:0}.col-lg-offset-1{margin-left:8.33333333%}.col-lg-offset-2{margin-left:16.66666667%}.col-lg-offset-3{margin-left:25%}.col-lg-offset-4{margin-left:33.33333333%}.col-lg-offset-5{margin-left:41.66666667%}.col-lg-offset-6{margin-left:50%}.col-lg-offset-7{margin-left:58.33333333%}.col-lg-offset-8{margin-left:66.66666667%}.col-lg-offset-9{margin-left:75%}.col-lg-offset-10{margin-left:83.33333333%}.col-lg-offset-11{margin-left:91.66666667%}.start-lg{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-lg{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-lg{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-lg{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-lg{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-lg{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-lg{-ms-flex-pack:distribute;justify-content:space-around}.between-lg{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-lg{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-lg{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}</style><link href=/index.xml rel=alternate type=application/rss+xml title="Hejin's Blog"><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css?family=Bree+Serif|Bungee+Shade" rel=stylesheet><script async src="https://www.googletagmanager.com/gtag/js?id=UA-xxx"></script></head><body><article class="post Chinese" id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class=header-title><a href=/>REMIND ME</a></div><div class=header-subtitle>What we forget shapes us; what we remember defines us.</div></header><div class="row end-md header-items"><div class=header-item><a href=https://github.com/hein-hp>Github</a></div><div class=header-item><a href=/about/>About</a></div></div><div class=row></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>Seata 网络通信源码解析</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2025-07-21 00:00:00 UTC">21 Jul 2025</time></div><div class=col-xs-6><div class=post-author><a href=/about/>@He Jin</a></div></div></div></header><div class=toc-container id=tocContainer><div class=toc-header>目录</div><div class=toc-content id=tocContent></div></div><div class="post-content markdown-body"><blockquote><p>源码版本：2.5.0</p></blockquote><p>在 Seata 中有三类角色，TC、RM、TM，Seata Server 作为 TC 协调分支事务的提交和回滚，各个资源作为 RM 和 TM，那么这三者之间是如何通信的呢？相信读完这篇文章之后，你就会知道答案。</p><h2 id=整体类层次结构>整体类层次结构</h2><p>我们先着眼大局，看一看 Seata 整个网络通信的类层次结构。</p><p><img src=assets/35bb8d1f4b218a42dd9a3a1a559735c7.png alt class=rounded-shadow-image loading=lazy></p><p>从类结构层次分析可以看出，Seata 的网络通信底层基于 Netty 实现。AbstractNettyRemoting 作为整个通信层的核心抽象基类，封装了通用的 RPC 基础能力，例如同步调用 (sendSync) 和异步调用 (sendAsync) 等方法。</p><p>本质上，网络通信的核心操作可归结为同步和异步两种调用模式，而请求与响应的区别主要在于报文内容的语义。</p><p>虽然 AbstractNettyRemoting 提供了这些基础方法，但不同角色（Server、TM、RM）在调用行为上是存在差异的，比如 Server 的请求调用需要明确指定目标客户端进行消息发送，而 Client（TM/RM）发送请求时通常无需指定特定的服务端实例。它们只需将请求发出，具体的服务端节点选择由实现类中的负载均衡机制完成。</p><p>为了体现这种角色差异，Seata 设计了 RemotingServer 和 RemotingClient 两个接口。它们都依赖于 AbstractNettyRemoting 提供的底层网络通信能力，并由各自的具体子类继承 AbstractNettyRemoting 来实现相应的接口功能。</p><h2 id=如何启动-server-和-client>如何启动 Server 和 Client</h2><p>下面分别以 Server 和 Client 的视角来看它们是如何启动的，以及在启动的时候需要做些什么事情。</p><h3 id=server-是怎么启动的>Server 是怎么启动的</h3><p>Seata Server 端作为一个独立的 SpringBoot 项目，要怎么样才能在 SpringBoot 启动的时候自动做点事呢？</p><p>Seata 的做法是实现了 CommandLineRunner 接口，我们主要关注它的 run 方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.apache.seata.server.ServerRunner#run</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>(String... args) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> start <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>();
</span></span><span style=display:flex><span>        seataServer.<span style=color:#a6e22e>start</span>(args);
</span></span><span style=display:flex><span>        started <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> cost <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>() <span style=color:#f92672>-</span> start;
</span></span><span style=display:flex><span>        LOGGER.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;\r\n you can visit seata console UI on namingserver. \r\n log path: {}.&#34;</span>, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>logPath</span>);
</span></span><span style=display:flex><span>        LOGGER.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;seata server started in {} millSeconds&#34;</span>, cost);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Throwable e) {
</span></span><span style=display:flex><span>        started <span style=color:#f92672>=</span> Boolean.<span style=color:#a6e22e>FALSE</span>;
</span></span><span style=display:flex><span>        LOGGER.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;seata server start error: {} &#34;</span>, e.<span style=color:#a6e22e>getMessage</span>(), e);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>exit</span>(<span style=color:#f92672>-</span>1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这其中核心的逻辑就在 seataServer.start() 方法中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.apache.seata.server.Server#start</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>start</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 参数解析器，用于解析启动参数</span>
</span></span><span style=display:flex><span>    ParameterParser parameterParser <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ParameterParser(args);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// initialize the metrics</span>
</span></span><span style=display:flex><span>    MetricsManager.<span style=color:#a6e22e>get</span>().<span style=color:#a6e22e>init</span>();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    ThreadPoolExecutor workingThreads <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ThreadPoolExecutor(
</span></span><span style=display:flex><span>            NettyServerConfig.<span style=color:#a6e22e>getMinServerPoolSize</span>(),
</span></span><span style=display:flex><span>            NettyServerConfig.<span style=color:#a6e22e>getMaxServerPoolSize</span>(),
</span></span><span style=display:flex><span>            NettyServerConfig.<span style=color:#a6e22e>getKeepAliveTime</span>(),
</span></span><span style=display:flex><span>            TimeUnit.<span style=color:#a6e22e>SECONDS</span>,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> LinkedBlockingQueue<span style=color:#f92672>&lt;&gt;</span>(NettyServerConfig.<span style=color:#a6e22e>getMaxTaskQueueSize</span>()),
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> NamedThreadFactory(<span style=color:#e6db74>&#34;ServerHandlerThread&#34;</span>, NettyServerConfig.<span style=color:#a6e22e>getMaxServerPoolSize</span>()),
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> ThreadPoolExecutor.<span style=color:#a6e22e>CallerRunsPolicy</span>());
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 127.0.0.1 and 0.0.0.0 are not valid here.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (NetUtil.<span style=color:#a6e22e>isValidIp</span>(parameterParser.<span style=color:#a6e22e>getHost</span>(), <span style=color:#66d9ef>false</span>)) {
</span></span><span style=display:flex><span>        XID.<span style=color:#a6e22e>setIpAddress</span>(parameterParser.<span style=color:#a6e22e>getHost</span>());
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        String preferredNetworks <span style=color:#f92672>=</span> ConfigurationFactory.<span style=color:#a6e22e>getInstance</span>().<span style=color:#a6e22e>getConfig</span>(REGISTRY_PREFERED_NETWORKS);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (StringUtils.<span style=color:#a6e22e>isNotBlank</span>(preferredNetworks)) {
</span></span><span style=display:flex><span>            XID.<span style=color:#a6e22e>setIpAddress</span>(NetUtil.<span style=color:#a6e22e>getLocalIp</span>(preferredNetworks.<span style=color:#a6e22e>split</span>(REGEX_SPLIT_CHAR)));
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            XID.<span style=color:#a6e22e>setIpAddress</span>(NetUtil.<span style=color:#a6e22e>getLocalIp</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 主要做这么几件事：
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 1. 设置 workingThreads 为 AbstractNettyRemoting 的 messageExecutor 处理器
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 2. 创建 ServerBootstrap，配置 Boss 和 Worker，传递 Netty 服务端配置，并设置 Seata Server 需要监听的端口
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 3. 设置出栈、入栈处理器 ServerHandler，它是一个 ChannelDuplexHandler 复合的处理器
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    NettyRemotingServer nettyRemotingServer <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> NettyRemotingServer(workingThreads);
</span></span><span style=display:flex><span>    XID.<span style=color:#a6e22e>setPort</span>(nettyRemotingServer.<span style=color:#a6e22e>getListenPort</span>());
</span></span><span style=display:flex><span>    UUIDGenerator.<span style=color:#a6e22e>init</span>(parameterParser.<span style=color:#a6e22e>getServerNode</span>());
</span></span><span style=display:flex><span>    ConfigurableListableBeanFactory beanFactory <span style=color:#f92672>=</span> ((ConfigurableApplicationContext)
</span></span><span style=display:flex><span>                    ObjectHolder.<span style=color:#a6e22e>INSTANCE</span>.<span style=color:#a6e22e>getObject</span>(OBJECT_KEY_SPRING_APPLICATION_CONTEXT))
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>getBeanFactory</span>();
</span></span><span style=display:flex><span>    DefaultCoordinator coordinator <span style=color:#f92672>=</span> DefaultCoordinator.<span style=color:#a6e22e>getInstance</span>(nettyRemotingServer);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (coordinator <span style=color:#66d9ef>instanceof</span> ApplicationListener) {
</span></span><span style=display:flex><span>        beanFactory.<span style=color:#a6e22e>registerSingleton</span>(NettyRemotingServer.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getName</span>(), nettyRemotingServer);
</span></span><span style=display:flex><span>        beanFactory.<span style=color:#a6e22e>registerSingleton</span>(DefaultCoordinator.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getName</span>(), coordinator);
</span></span><span style=display:flex><span>        ((ConfigurableApplicationContext) ObjectHolder.<span style=color:#a6e22e>INSTANCE</span>.<span style=color:#a6e22e>getObject</span>(OBJECT_KEY_SPRING_APPLICATION_CONTEXT))
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>addApplicationListener</span>((ApplicationListener<span style=color:#f92672>&lt;?&gt;</span>) coordinator);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// log store mode: file, db, redis</span>
</span></span><span style=display:flex><span>    SessionHolder.<span style=color:#a6e22e>init</span>();
</span></span><span style=display:flex><span>    LockerManagerFactory.<span style=color:#a6e22e>init</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 基于 ScheduledThreadPoolExecutor 启动一系列定时任务，用于重试事务提交/回滚、undolog 删除等</span>
</span></span><span style=display:flex><span>    coordinator.<span style=color:#a6e22e>init</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 设置事务处理 Handler 为 DefaultCoordinator</span>
</span></span><span style=display:flex><span>    nettyRemotingServer.<span style=color:#a6e22e>setHandler</span>(coordinator);
</span></span><span style=display:flex><span>    Optional.<span style=color:#a6e22e>ofNullable</span>(seataInstanceStrategy).<span style=color:#a6e22e>ifPresent</span>(SeataInstanceStrategy::init);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// let ServerRunner do destroy instead ShutdownHook, see https://github.com/seata/seata/issues/4028</span>
</span></span><span style=display:flex><span>    ServerRunner.<span style=color:#a6e22e>addDisposable</span>(coordinator);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Server 初始化</span>
</span></span><span style=display:flex><span>    nettyRemotingServer.<span style=color:#a6e22e>init</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>最后的 nettyRemotingServer.init() 是整个 Seata Server 启动的重要逻辑，主要做了这么几件事：</p><ol><li>注册一系列处理器</li><li>启动 ScheduledExecutorService，每 3 秒执行一次，主要用于清理过期的 MessageFuture</li><li>启动 ServerBootStrap 并将 TC 服务注册到注册中心，比如 Nacos</li></ol><h4 id=注册处理器>注册处理器</h4><p>在 Seata 内部，用一个 Pair 对象关联了处理器和线程池，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Pair</span><span style=color:#f92672>&lt;</span>T1, T2<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> T1 first;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> T2 second;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Pair</span>(T1 first, T2 second) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>first</span> <span style=color:#f92672>=</span> first;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>second</span> <span style=color:#f92672>=</span> second;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> T1 <span style=color:#a6e22e>getFirst</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> first;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> T2 <span style=color:#a6e22e>getSecond</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> second;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>而注册处理器本质就是将报文类型、处理该报文的处理器以及具体执行的线程池关联起来，存到一张哈希表中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// AbstractNettyRemotingServer</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>final</span> Map<span style=color:#f92672>&lt;</span>Integer<span style=color:#75715e>/*MessageType*/</span>, 
</span></span><span style=display:flex><span>    Pair<span style=color:#f92672>&lt;</span>RemotingProcessor, ExecutorService<span style=color:#f92672>&gt;&gt;</span> processorTable <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>(32);
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.apache.seata.core.rpc.netty.NettyRemotingServer#registerProcessor</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>registerProcessor</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1. registry on request message processor</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 处理 RM/TM 客户端请求报文的处理器</span>
</span></span><span style=display:flex><span>    ServerOnRequestProcessor onRequestProcessor <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ServerOnRequestProcessor(<span style=color:#66d9ef>this</span>, getHandler());
</span></span><span style=display:flex><span>    ShutdownHook.<span style=color:#a6e22e>getInstance</span>().<span style=color:#a6e22e>addDisposable</span>(onRequestProcessor);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_BRANCH_REGISTER</span>, onRequestProcessor, messageExecutor);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_BRANCH_STATUS_REPORT</span>, onRequestProcessor, messageExecutor);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_GLOBAL_BEGIN</span>, onRequestProcessor, messageExecutor);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_GLOBAL_COMMIT</span>, onRequestProcessor, messageExecutor);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_GLOBAL_LOCK_QUERY</span>, onRequestProcessor, messageExecutor);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_GLOBAL_REPORT</span>, onRequestProcessor, messageExecutor);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_GLOBAL_ROLLBACK</span>, onRequestProcessor, messageExecutor);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_GLOBAL_STATUS</span>, onRequestProcessor, messageExecutor);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_SEATA_MERGE</span>, onRequestProcessor, messageExecutor);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. registry on response message processor</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 处理 RM/TM 客户端响应报文的处理器</span>
</span></span><span style=display:flex><span>    ServerOnResponseProcessor onResponseProcessor <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ServerOnResponseProcessor(getHandler(), getFutures());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_BRANCH_COMMIT_RESULT</span>, onResponseProcessor, branchResultMessageExecutor);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_BRANCH_ROLLBACK_RESULT</span>, onResponseProcessor, branchResultMessageExecutor);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3. registry rm message processor</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 处理 RM 的注册请求的处理器</span>
</span></span><span style=display:flex><span>    RegRmProcessor regRmProcessor <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> RegRmProcessor(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_REG_RM</span>, regRmProcessor, messageExecutor);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 4. registry tm message processor</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 处理 TM 的注册请求的处理器</span>
</span></span><span style=display:flex><span>    RegTmProcessor regTmProcessor <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> RegTmProcessor(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_REG_CLT</span>, regTmProcessor, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 5. registry heartbeat message processor</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 处理客户端发送的心跳请求的处理器</span>
</span></span><span style=display:flex><span>    ServerHeartbeatProcessor heartbeatMessageProcessor <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ServerHeartbeatProcessor(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_HEARTBEAT_MSG</span>, heartbeatMessageProcessor, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// org.apache.seata.core.rpc.netty.AbstractNettyRemotingServer#registerProcessor</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>registerProcessor</span>(<span style=color:#66d9ef>int</span> messageType, RemotingProcessor processor, ExecutorService executor) {
</span></span><span style=display:flex><span>    Pair<span style=color:#f92672>&lt;</span>RemotingProcessor, ExecutorService<span style=color:#f92672>&gt;</span> pair <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Pair<span style=color:#f92672>&lt;&gt;</span>(processor, executor);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>processorTable</span>.<span style=color:#a6e22e>put</span>(messageType, pair);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>同样，你可能会注意到，在注册处理器时，有一些注册时传入的线程池是 null，那么对应的报文会由哪个线程执行呢？后面会提到。</p><h4 id=初始化定时线程池>初始化定时线程池</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.apache.seata.core.rpc.netty.AbstractNettyRemoting#init</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init</span>() {
</span></span><span style=display:flex><span>    timerExecutor.<span style=color:#a6e22e>scheduleAtFixedRate</span>(
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Runnable() {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> (Map.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>Integer, MessageFuture<span style=color:#f92672>&gt;</span> entry : futures.<span style=color:#a6e22e>entrySet</span>()) {
</span></span><span style=display:flex><span>                        MessageFuture future <span style=color:#f92672>=</span> entry.<span style=color:#a6e22e>getValue</span>();
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (future.<span style=color:#a6e22e>isTimeout</span>()) {
</span></span><span style=display:flex><span>                            futures.<span style=color:#a6e22e>remove</span>(entry.<span style=color:#a6e22e>getKey</span>());
</span></span><span style=display:flex><span>                            RpcMessage rpcMessage <span style=color:#f92672>=</span> future.<span style=color:#a6e22e>getRequestMessage</span>();
</span></span><span style=display:flex><span>                            future.<span style=color:#a6e22e>setResultMessage</span>(<span style=color:#66d9ef>new</span> TimeoutException(String.<span style=color:#a6e22e>format</span>(
</span></span><span style=display:flex><span>                                    <span style=color:#e6db74>&#34;msgId: %s ,msgType: %s ,msg: %s ,request timeout&#34;</span>,
</span></span><span style=display:flex><span>                                    rpcMessage.<span style=color:#a6e22e>getId</span>(),
</span></span><span style=display:flex><span>                                    String.<span style=color:#a6e22e>valueOf</span>(rpcMessage.<span style=color:#a6e22e>getMessageType</span>()),
</span></span><span style=display:flex><span>                                    rpcMessage.<span style=color:#a6e22e>getBody</span>().<span style=color:#a6e22e>toString</span>())));
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> (LOGGER.<span style=color:#a6e22e>isDebugEnabled</span>()) {
</span></span><span style=display:flex><span>                                LOGGER.<span style=color:#a6e22e>debug</span>(
</span></span><span style=display:flex><span>                                        <span style=color:#e6db74>&#34;timeout clear future: {}&#34;</span>,
</span></span><span style=display:flex><span>                                        entry.<span style=color:#a6e22e>getValue</span>().<span style=color:#a6e22e>getRequestMessage</span>().<span style=color:#a6e22e>getBody</span>());
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    nowMills <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            TIMEOUT_CHECK_INTERVAL,
</span></span><span style=display:flex><span>            TIMEOUT_CHECK_INTERVAL,
</span></span><span style=display:flex><span>            TimeUnit.<span style=color:#a6e22e>MILLISECONDS</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个没啥好说的，就是启动了一个定时任务，定时清理那些超时的 MessageFuture，这里 MessageFuture 是 Seata 将异步调用转为同步调用的关键，后面也会详细说到。</p><h4 id=启动-serverbootstrap>启动 ServerBootStrap</h4><p>最后启动 ServerBootStrap，这差不多就是 Netty 的内容了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>start</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> port <span style=color:#f92672>=</span> getListenPort();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>serverBootstrap</span>
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>group</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>eventLoopGroupBoss</span>, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>eventLoopGroupWorker</span>)
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>channel</span>(NettyServerConfig.<span style=color:#a6e22e>SERVER_CHANNEL_CLAZZ</span>)
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>option</span>(ChannelOption.<span style=color:#a6e22e>SO_BACKLOG</span>, nettyServerConfig.<span style=color:#a6e22e>getSoBackLogSize</span>())
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>option</span>(ChannelOption.<span style=color:#a6e22e>SO_REUSEADDR</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>childOption</span>(ChannelOption.<span style=color:#a6e22e>SO_KEEPALIVE</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>childOption</span>(ChannelOption.<span style=color:#a6e22e>TCP_NODELAY</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>childOption</span>(ChannelOption.<span style=color:#a6e22e>SO_SNDBUF</span>, nettyServerConfig.<span style=color:#a6e22e>getServerSocketSendBufSize</span>())
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>childOption</span>(ChannelOption.<span style=color:#a6e22e>SO_RCVBUF</span>, nettyServerConfig.<span style=color:#a6e22e>getServerSocketResvBufSize</span>())
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>childOption</span>(
</span></span><span style=display:flex><span>                    ChannelOption.<span style=color:#a6e22e>WRITE_BUFFER_WATER_MARK</span>,
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>new</span> WriteBufferWaterMark(
</span></span><span style=display:flex><span>                            nettyServerConfig.<span style=color:#a6e22e>getWriteBufferLowWaterMark</span>(),
</span></span><span style=display:flex><span>                            nettyServerConfig.<span style=color:#a6e22e>getWriteBufferHighWaterMark</span>()))
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>localAddress</span>(<span style=color:#66d9ef>new</span> InetSocketAddress(port))
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>childHandler</span>(<span style=color:#66d9ef>new</span> ChannelInitializer<span style=color:#f92672>&lt;</span>SocketChannel<span style=color:#f92672>&gt;</span>() {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initChannel</span>(SocketChannel ch) {
</span></span><span style=display:flex><span>                    ch.<span style=color:#a6e22e>pipeline</span>()
</span></span><span style=display:flex><span>                            .<span style=color:#a6e22e>addLast</span>(<span style=color:#66d9ef>new</span> IdleStateHandler(nettyServerConfig.<span style=color:#a6e22e>getChannelMaxReadIdleSeconds</span>(), 0, 0))
</span></span><span style=display:flex><span>                            .<span style=color:#a6e22e>addLast</span>(<span style=color:#66d9ef>new</span> ProtocolDetectHandler(<span style=color:#66d9ef>new</span> ProtocolDetector<span style=color:#f92672>[]</span> {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>new</span> Http2Detector(getChannelHandlers()),
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>new</span> SeataDetector(getChannelHandlers()),
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>new</span> HttpDetector()
</span></span><span style=display:flex><span>                            }));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>serverBootstrap</span>.<span style=color:#a6e22e>bind</span>(port).<span style=color:#a6e22e>sync</span>();
</span></span><span style=display:flex><span>        LOGGER.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Server started, service listen port: {}&#34;</span>, getListenPort());
</span></span><span style=display:flex><span>        Instance instance <span style=color:#f92672>=</span> Instance.<span style=color:#a6e22e>getInstance</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Lines 177-180 are just for compatibility with test cases</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (instance.<span style=color:#a6e22e>getTransaction</span>() <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            Instance.<span style=color:#a6e22e>getInstance</span>().<span style=color:#a6e22e>setTransaction</span>(<span style=color:#66d9ef>new</span> Node.<span style=color:#a6e22e>Endpoint</span>(XID.<span style=color:#a6e22e>getIpAddress</span>(), XID.<span style=color:#a6e22e>getPort</span>(), <span style=color:#e6db74>&#34;netty&#34;</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (RegistryService<span style=color:#f92672>&lt;?&gt;</span> registryService : MultiRegistryFactory.<span style=color:#a6e22e>getInstances</span>()) {
</span></span><span style=display:flex><span>            registryService.<span style=color:#a6e22e>register</span>(Instance.<span style=color:#a6e22e>getInstance</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        initialized.<span style=color:#a6e22e>set</span>(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (SocketException se) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(<span style=color:#e6db74>&#34;Server start failed, the listen port: &#34;</span> <span style=color:#f92672>+</span> getListenPort(), se);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Exception exx) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(<span style=color:#e6db74>&#34;Server start failed&#34;</span>, exx);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ServerBootstrap 启动时的 childOption 属于网络部分的内容，不过多解释。</p><p>这里你可能有一点疑问，在 pipeline 中仅仅只是添加了一个 ProtocolDetectHandler，那业务处理器呢？</p><p>到这里为止，你只需要记住，创建 Http2Detector 和 SeataDetector 时的入参即为 ServerHandler，它是在创建 NettyRemotingServer 时在 AbstractNettyRemotingServer 的构造函数被设置的，其余的先按下不表。</p><h3 id=client-是怎么启动的>Client 是怎么启动的</h3><p>对于 Client 来说，由于我们一般是在 SpringBoot 中使用 Seata，所以我们需要关注的点在 SeataAutoConfiguratio 类中。</p><p>在这个类里面创建了一个 GlobalTransactionScanner 对象，我们注意到它实现了 InitializingBean，所以将目光转移到 afterPropertiesSet 方法上。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>afterPropertiesSet</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (disableGlobalTransaction) { <span style=color:#75715e>// 默认是false</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (LOGGER.<span style=color:#a6e22e>isInfoEnabled</span>()) {
</span></span><span style=display:flex><span>            LOGGER.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Global transaction is disabled.&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        ConfigurationFactory.<span style=color:#a6e22e>getInstance</span>()
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>addConfigListener</span>(
</span></span><span style=display:flex><span>                        ConfigurationKeys.<span style=color:#a6e22e>DISABLE_GLOBAL_TRANSACTION</span>, (CachedConfigurationChangeListener) <span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (initialized.<span style=color:#a6e22e>compareAndSet</span>(<span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>true</span>)) {
</span></span><span style=display:flex><span>        initClient();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>findBusinessBeanNamesNeededEnhancement</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>果然在这个方法里面进行了 TM 和 RM 的初始化。</p><h4 id=tm-的初始化>TM 的初始化</h4><p>对于 TM 来说，初始化的逻辑如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init</span>(String applicationId, String transactionServiceGroup, String accessKey, String secretKey) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 主要做这么几件事
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 1. 创建线程池作为 AbstractNettyRemotingClient 的 messageExecutor 消息执行器
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 2. 设置事务角色 transactionRole 为 TMROLE
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 3. 创建 Bootstrap 并设置出栈、入栈处理器 ClientHandler 和 ChannelEventHandler
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 4. 创建客户端 Channel 管理器 NettyClientChannelManager
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    TmNettyRemotingClient tmNettyRemotingClient <span style=color:#f92672>=</span> TmNettyRemotingClient.<span style=color:#a6e22e>getInstance</span>(applicationId, transactionServiceGroup, accessKey, secretKey);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 主要做这么几件事：
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 1. 注册一系列处理器
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 2. 启动定时任务定时对事务组内的 Server 发起连接，如果连接断开，则尝试重新建立连接
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 3. 如果客户端允许报文批量发送，则创建 mergeSendExecutorService，并提交 MergedSendRunnable 任务
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 4. 启动定时任务每 3 秒清理过期的 MessageFuture
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 5. 启动客户端 Bootstrap，装载 pipeline 上的处理器
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 6. 初始化连接 initConnection，就是从注册中心拿到 Server 的地址，发起连接
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    tmNettyRemotingClient.<span style=color:#a6e22e>init</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注册处理器代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>registerProcessor</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1.registry TC response processor</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 处理 TC Server 响应消息的处理器，即 RM 发出请求到 TC 之后，TC 响应回来的消息处理</span>
</span></span><span style=display:flex><span>    ClientOnResponseProcessor onResponseProcessor <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ClientOnResponseProcessor(
</span></span><span style=display:flex><span>            mergeMsgMap, <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>getFutures</span>(), childToParentMap, getTransactionMessageHandler());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_SEATA_MERGE_RESULT</span>, onResponseProcessor, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_GLOBAL_BEGIN_RESULT</span>, onResponseProcessor, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_GLOBAL_COMMIT_RESULT</span>, onResponseProcessor, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_GLOBAL_REPORT_RESULT</span>, onResponseProcessor, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_GLOBAL_ROLLBACK_RESULT</span>, onResponseProcessor, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_GLOBAL_STATUS_RESULT</span>, onResponseProcessor, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_REG_CLT_RESULT</span>, onResponseProcessor, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_BATCH_RESULT_MSG</span>, onResponseProcessor, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2.registry heartbeat message processor</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 处理 TC Server 响应消息的处理器，即 TM 发出心跳请求到 TC 之后，TC 响应回来的消息处理</span>
</span></span><span style=display:flex><span>    ClientHeartbeatProcessor clientHeartbeatProcessor <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ClientHeartbeatProcessor();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_HEARTBEAT_MSG</span>, clientHeartbeatProcessor, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>启动客户端 Bootstrap 的逻辑如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>start</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>bootstrap</span>
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>group</span>(eventLoopGroupWorker)
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>channel</span>(nettyClientConfig.<span style=color:#a6e22e>getClientChannelClazz</span>())
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>option</span>(ChannelOption.<span style=color:#a6e22e>TCP_NODELAY</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>option</span>(ChannelOption.<span style=color:#a6e22e>SO_KEEPALIVE</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>option</span>(ChannelOption.<span style=color:#a6e22e>CONNECT_TIMEOUT_MILLIS</span>, nettyClientConfig.<span style=color:#a6e22e>getConnectTimeoutMillis</span>())
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>option</span>(ChannelOption.<span style=color:#a6e22e>SO_SNDBUF</span>, nettyClientConfig.<span style=color:#a6e22e>getClientSocketSndBufSize</span>())
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>option</span>(ChannelOption.<span style=color:#a6e22e>SO_RCVBUF</span>, nettyClientConfig.<span style=color:#a6e22e>getClientSocketRcvBufSize</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (nettyClientConfig.<span style=color:#a6e22e>enableNative</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (PlatformDependent.<span style=color:#a6e22e>isOsx</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (LOGGER.<span style=color:#a6e22e>isInfoEnabled</span>()) {
</span></span><span style=display:flex><span>                LOGGER.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;client run on macOS&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            bootstrap
</span></span><span style=display:flex><span>                    .<span style=color:#a6e22e>option</span>(EpollChannelOption.<span style=color:#a6e22e>EPOLL_MODE</span>, EpollMode.<span style=color:#a6e22e>EDGE_TRIGGERED</span>)
</span></span><span style=display:flex><span>                    .<span style=color:#a6e22e>option</span>(EpollChannelOption.<span style=color:#a6e22e>TCP_QUICKACK</span>, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    bootstrap.<span style=color:#a6e22e>handler</span>(<span style=color:#66d9ef>new</span> ChannelInitializer<span style=color:#f92672>&lt;</span>SocketChannel<span style=color:#f92672>&gt;</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initChannel</span>(SocketChannel ch) {
</span></span><span style=display:flex><span>            ChannelPipeline pipeline <span style=color:#f92672>=</span> ch.<span style=color:#a6e22e>pipeline</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (nettyClientConfig.<span style=color:#a6e22e>getProtocol</span>().<span style=color:#a6e22e>equals</span>(Protocol.<span style=color:#a6e22e>GRPC</span>.<span style=color:#a6e22e>value</span>)) {
</span></span><span style=display:flex><span>                pipeline.<span style=color:#a6e22e>addLast</span>(Http2FrameCodecBuilder.<span style=color:#a6e22e>forClient</span>().<span style=color:#a6e22e>build</span>())
</span></span><span style=display:flex><span>                        .<span style=color:#a6e22e>addLast</span>(<span style=color:#66d9ef>new</span> Http2MultiplexHandler(<span style=color:#66d9ef>new</span> ChannelDuplexHandler()));
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                pipeline.<span style=color:#a6e22e>addLast</span>(<span style=color:#66d9ef>new</span> IdleStateHandler(
</span></span><span style=display:flex><span>                        nettyClientConfig.<span style=color:#a6e22e>getChannelMaxReadIdleSeconds</span>(),
</span></span><span style=display:flex><span>                        nettyClientConfig.<span style=color:#a6e22e>getChannelMaxWriteIdleSeconds</span>(),
</span></span><span style=display:flex><span>                        nettyClientConfig.<span style=color:#a6e22e>getChannelMaxAllIdleSeconds</span>()));
</span></span><span style=display:flex><span>                pipeline.<span style=color:#a6e22e>addLast</span>(<span style=color:#66d9ef>new</span> ProtocolDecoderV1()).<span style=color:#a6e22e>addLast</span>(<span style=color:#66d9ef>new</span> ProtocolEncoderV1());
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (channelHandlers <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    addChannelPipelineLast(ch, channelHandlers);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (initialized.<span style=color:#a6e22e>compareAndSet</span>(<span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>true</span>) <span style=color:#f92672>&amp;&amp;</span> LOGGER.<span style=color:#a6e22e>isInfoEnabled</span>()) {
</span></span><span style=display:flex><span>        LOGGER.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;NettyClientBootstrap has started&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>由于客户端的协议版本根据不同的 Seata 版本是可以确定的，所以这里直接添加了 V1 版本的编解码器，这里 channelHandlers 其实就是 ClientHandler 和 ChannelEventHandler，它们都是 Netty 中的复合处理器。</p><h4 id=rm-的初始化>RM 的初始化</h4><p>RM 的初始化大致逻辑和 TM 是类似的，这里只简单看一下注册处理器的部分。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>registerProcessor</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1.registry rm client handle branch commit processor</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 处理 TC Server 发起的分支提交的请求</span>
</span></span><span style=display:flex><span>    RmBranchCommitProcessor rmBranchCommitProcessor <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> RmBranchCommitProcessor(getTransactionMessageHandler(), <span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_BRANCH_COMMIT</span>, rmBranchCommitProcessor, messageExecutor);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2.registry rm client handle branch rollback processor</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 处理 TC Server 发起的分支回滚的请求</span>
</span></span><span style=display:flex><span>    RmBranchRollbackProcessor rmBranchRollbackProcessor <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> RmBranchRollbackProcessor(getTransactionMessageHandler(), <span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_BRANCH_ROLLBACK</span>, rmBranchRollbackProcessor, messageExecutor);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3.registry rm handler undo log processor</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 处理 TC Server 发起的 UndoLog 删除请求</span>
</span></span><span style=display:flex><span>    RmUndoLogProcessor rmUndoLogProcessor <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> RmUndoLogProcessor(getTransactionMessageHandler());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_RM_DELETE_UNDOLOG</span>, rmUndoLogProcessor, messageExecutor);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 4.registry TC response processor</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 处理 TC Server 响应消息的处理器，即 RM 发出请求到 TC 之后，TC 响应回来的消息处理</span>
</span></span><span style=display:flex><span>    ClientOnResponseProcessor onResponseProcessor <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ClientOnResponseProcessor(
</span></span><span style=display:flex><span>            mergeMsgMap, <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>getFutures</span>(), childToParentMap, getTransactionMessageHandler());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_SEATA_MERGE_RESULT</span>, onResponseProcessor, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_BRANCH_REGISTER_RESULT</span>, onResponseProcessor, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_BRANCH_STATUS_REPORT_RESULT</span>, onResponseProcessor, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_GLOBAL_LOCK_QUERY_RESULT</span>, onResponseProcessor, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_REG_RM_RESULT</span>, onResponseProcessor, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_BATCH_RESULT_MSG</span>, onResponseProcessor, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 5.registry heartbeat message processor</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 处理 TC Server 响应消息的处理器，即 RM 发出心跳请求到 TC 之后，TC 响应回来的消息处理</span>
</span></span><span style=display:flex><span>    ClientHeartbeatProcessor clientHeartbeatProcessor <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ClientHeartbeatProcessor();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>registerProcessor</span>(MessageType.<span style=color:#a6e22e>TYPE_HEARTBEAT_MSG</span>, clientHeartbeatProcessor, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=如何发送和处理报文>如何发送和处理报文</h2><p>厘清了 Seata Server 和 Client 的大致启动流程之后，我们就可以深入的看一看 Seata 是如何进行报文发送和处理的。</p><p>前面我们也说过了，发送请求和处理报文的核心逻辑是在 AbstractNettyRemoting 中，接下来就看一看这个类。</p><h3 id=同步和异步>同步和异步</h3><p>先简单说一说什么是同步和异步。</p><p>同步 Synchronous 和异步 Asynchronous，本质上是描述了程序在处理多个事件或者任务时的不同行为模式。</p><p>同步是指一个过程必须等待另一个过程完成之后才能继续进行。换句话说，在同步操作中，调用方发出请求后会一直阻塞等待直到接收到响应结果、或者超时才会继续执行后续代码。</p><p>相比之下，异步则允许调用者在请求后不必等待响应就可以向下执行，但当请求完成时，会以某种方式将响应通知到调用者（如通过回调函数、Future），异步模型可以提高并发性和效率。</p><p>从另一个角度来说，同步调用需要发起调用的线程获取结果，而异步调用则是由异步线程将结果放到某个地方（Future）或者是异步线程去执行事先准备好的调用成功/失败的回调方法（回调函数）。</p><p>下面是一个简单的例子，展示了三种调用方式，同步、异步 Future、异步 Callback。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.fhj;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> lombok.extern.slf4j.Slf4j;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.CompletableFuture;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.ExecutorService;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.Executors;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.Future;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.function.Consumer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 同步调用接口</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>SyncAdder</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) <span style=color:#66d9ef>throws</span> InterruptedException;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 异步 Future 调用接口</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>AsyncFutureAdder</span> {
</span></span><span style=display:flex><span>    CompletableFuture<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>addAsync</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 异步 Callback 调用接口</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>AsyncCallbackAdder</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>addAsync</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b, Consumer<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> callback);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 实现类</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Slf4j</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AdderService</span> <span style=color:#66d9ef>implements</span> SyncAdder, AsyncFutureAdder, AsyncCallbackAdder {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> ExecutorService executor <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newCachedThreadPool</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 模拟耗时操作</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>simulateDelay</span>() <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        Thread.<span style=color:#a6e22e>sleep</span>(1000); <span style=color:#75715e>// 1秒延迟</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 同步实现</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;执行计算&#34;</span>);
</span></span><span style=display:flex><span>        simulateDelay();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 异步 Future 实现</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> CompletableFuture<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>addAsync</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> CompletableFuture.<span style=color:#a6e22e>supplyAsync</span>(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;执行计算&#34;</span>);
</span></span><span style=display:flex><span>                simulateDelay();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> add(a, b);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(e);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }, executor);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 异步 Callback 实现</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>addAsync</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b, Consumer<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> callback) {
</span></span><span style=display:flex><span>        executor.<span style=color:#a6e22e>execute</span>(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;执行计算&#34;</span>);
</span></span><span style=display:flex><span>                simulateDelay();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> result <span style=color:#f92672>=</span> add(a, b);
</span></span><span style=display:flex><span>                callback.<span style=color:#a6e22e>accept</span>(result);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>interrupt</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>shutdown</span>() {
</span></span><span style=display:flex><span>        executor.<span style=color:#a6e22e>shutdown</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Slf4j</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Example</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        AdderService adder <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AdderService();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 1. 同步调用</span>
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;--- 同步调用开始 ---&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> syncResult <span style=color:#f92672>=</span> adder.<span style=color:#a6e22e>add</span>(3, 5);
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;同步结果: &#34;</span> <span style=color:#f92672>+</span> syncResult);
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;主线程继续执行...\n&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 2. 异步 Future 调用</span>
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;--- 异步Future调用开始 ---&#34;</span>);
</span></span><span style=display:flex><span>        Future<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> future <span style=color:#f92672>=</span> adder.<span style=color:#a6e22e>addAsync</span>(10, 20);
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;主线程继续执行...&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻塞获取结果</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> futureResult <span style=color:#f92672>=</span> future.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Future结果: &#34;</span> <span style=color:#f92672>+</span> futureResult <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;\n&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 3. 异步 Callback 调用</span>
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;--- 异步Callback调用开始 ---&#34;</span>);
</span></span><span style=display:flex><span>        adder.<span style=color:#a6e22e>addAsync</span>(100, 200, result <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Callback结果: &#34;</span> <span style=color:#f92672>+</span> result);
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;主线程继续执行...&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 等待异步操作完成</span>
</span></span><span style=display:flex><span>        Thread.<span style=color:#a6e22e>sleep</span>(1500);
</span></span><span style=display:flex><span>        adder.<span style=color:#a6e22e>shutdown</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>15:46:43.<span style=color:#a6e22e>842</span> <span style=color:#f92672>[</span>main<span style=color:#f92672>]</span> INFO com.<span style=color:#a6e22e>fhj</span>.<span style=color:#a6e22e>Example</span> <span style=color:#f92672>-</span> <span style=color:#f92672>---</span> 同步调用开始 <span style=color:#f92672>---</span>
</span></span><span style=display:flex><span>15:46:43.<span style=color:#a6e22e>844</span> <span style=color:#f92672>[</span>main<span style=color:#f92672>]</span> INFO com.<span style=color:#a6e22e>fhj</span>.<span style=color:#a6e22e>AdderService</span> <span style=color:#f92672>-</span> 执行计算
</span></span><span style=display:flex><span>15:46:44.<span style=color:#a6e22e>850</span> <span style=color:#f92672>[</span>main<span style=color:#f92672>]</span> INFO com.<span style=color:#a6e22e>fhj</span>.<span style=color:#a6e22e>Example</span> <span style=color:#f92672>-</span> 同步结果: 8
</span></span><span style=display:flex><span>15:46:44.<span style=color:#a6e22e>850</span> <span style=color:#f92672>[</span>main<span style=color:#f92672>]</span> INFO com.<span style=color:#a6e22e>fhj</span>.<span style=color:#a6e22e>Example</span> <span style=color:#f92672>-</span> 主线程继续执行...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>15:46:44.<span style=color:#a6e22e>850</span> <span style=color:#f92672>[</span>main<span style=color:#f92672>]</span> INFO com.<span style=color:#a6e22e>fhj</span>.<span style=color:#a6e22e>Example</span> <span style=color:#f92672>-</span> <span style=color:#f92672>---</span> 异步Future调用开始 <span style=color:#f92672>---</span>
</span></span><span style=display:flex><span>15:46:44.<span style=color:#a6e22e>857</span> <span style=color:#f92672>[</span>pool<span style=color:#f92672>-</span>1<span style=color:#f92672>-</span>thread<span style=color:#f92672>-</span>1<span style=color:#f92672>]</span> INFO com.<span style=color:#a6e22e>fhj</span>.<span style=color:#a6e22e>AdderService</span> <span style=color:#f92672>-</span> 执行计算
</span></span><span style=display:flex><span>15:46:44.<span style=color:#a6e22e>857</span> <span style=color:#f92672>[</span>main<span style=color:#f92672>]</span> INFO com.<span style=color:#a6e22e>fhj</span>.<span style=color:#a6e22e>Example</span> <span style=color:#f92672>-</span> 主线程继续执行...
</span></span><span style=display:flex><span>15:46:45.<span style=color:#a6e22e>863</span> <span style=color:#f92672>[</span>pool<span style=color:#f92672>-</span>1<span style=color:#f92672>-</span>thread<span style=color:#f92672>-</span>1<span style=color:#f92672>]</span> INFO com.<span style=color:#a6e22e>fhj</span>.<span style=color:#a6e22e>AdderService</span> <span style=color:#f92672>-</span> 执行计算
</span></span><span style=display:flex><span>15:46:46.<span style=color:#a6e22e>865</span> <span style=color:#f92672>[</span>main<span style=color:#f92672>]</span> INFO com.<span style=color:#a6e22e>fhj</span>.<span style=color:#a6e22e>Example</span> <span style=color:#f92672>-</span> Future结果: 30
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>15:46:46.<span style=color:#a6e22e>865</span> <span style=color:#f92672>[</span>main<span style=color:#f92672>]</span> INFO com.<span style=color:#a6e22e>fhj</span>.<span style=color:#a6e22e>Example</span> <span style=color:#f92672>-</span> <span style=color:#f92672>---</span> 异步Callback调用开始 <span style=color:#f92672>---</span>
</span></span><span style=display:flex><span>15:46:46.<span style=color:#a6e22e>868</span> <span style=color:#f92672>[</span>main<span style=color:#f92672>]</span> INFO com.<span style=color:#a6e22e>fhj</span>.<span style=color:#a6e22e>Example</span> <span style=color:#f92672>-</span> 主线程继续执行...
</span></span><span style=display:flex><span>15:46:46.<span style=color:#a6e22e>868</span> <span style=color:#f92672>[</span>pool<span style=color:#f92672>-</span>1<span style=color:#f92672>-</span>thread<span style=color:#f92672>-</span>1<span style=color:#f92672>]</span> INFO com.<span style=color:#a6e22e>fhj</span>.<span style=color:#a6e22e>AdderService</span> <span style=color:#f92672>-</span> 执行计算
</span></span><span style=display:flex><span>15:46:47.<span style=color:#a6e22e>871</span> <span style=color:#f92672>[</span>pool<span style=color:#f92672>-</span>1<span style=color:#f92672>-</span>thread<span style=color:#f92672>-</span>1<span style=color:#f92672>]</span> INFO com.<span style=color:#a6e22e>fhj</span>.<span style=color:#a6e22e>AdderService</span> <span style=color:#f92672>-</span> 执行计算
</span></span><span style=display:flex><span>15:46:48.<span style=color:#a6e22e>876</span> <span style=color:#f92672>[</span>pool<span style=color:#f92672>-</span>1<span style=color:#f92672>-</span>thread<span style=color:#f92672>-</span>1<span style=color:#f92672>]</span> INFO com.<span style=color:#a6e22e>fhj</span>.<span style=color:#a6e22e>Example</span> <span style=color:#f92672>-</span> Callback结果: 300
</span></span></code></pre></div><p>从结果中，至少可以看出三点，</p><ul><li>一是异步 Future 和异步 Callback 并不会阻塞主线程向下执行。</li><li>二是异步调用时计算结果的不是主线程，对于异步 Callback 来说，甚至处理结果的都不是主线程。</li><li>最后，Future 和 Callback 的区别在于 Future 只是由异步线程将结果存储在了一个地方（CompletableFuture#result），但是后续获取结果还是需要主线程（或者其他线程）调用 get 方法，而 Callback 的话，其实就相当于预先设定了结果的处理方式，由异步线程去执行就好了。</li></ul><p>当然，CompletableFuture 也是可以作回调的，比如调用 whenComplete 方法。</p><h3 id=异步调用>异步调用</h3><p>Netty 作为一个高性能的异步 IO 框架，它的设计核心就是异步的，所以基于 Netty 进行异步调用是比较简单的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.apache.seata.core.rpc.netty.AbstractNettyRemoting#sendAsync</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sendAsync</span>(Channel channel, RpcMessage rpcMessage) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (MsgVersionHelper.<span style=color:#a6e22e>versionNotSupport</span>(channel, rpcMessage)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (LOGGER.<span style=color:#a6e22e>isDebugEnabled</span>()) {
</span></span><span style=display:flex><span>            LOGGER.<span style=color:#a6e22e>debug</span>(
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#34;Message sending will be skipped as the client version does not support it,{}&#34;</span>, rpcMessage);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    channelWritableCheck(channel, rpcMessage.<span style=color:#a6e22e>getBody</span>());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (LOGGER.<span style=color:#a6e22e>isDebugEnabled</span>()) {
</span></span><span style=display:flex><span>        LOGGER.<span style=color:#a6e22e>debug</span>(<span style=color:#e6db74>&#34;write message:&#34;</span> <span style=color:#f92672>+</span> rpcMessage.<span style=color:#a6e22e>getBody</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;, channel:&#34;</span> <span style=color:#f92672>+</span> channel <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;,active?&#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>+</span> channel.<span style=color:#a6e22e>isActive</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;,writable?&#34;</span> <span style=color:#f92672>+</span> channel.<span style=color:#a6e22e>isWritable</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;,isopen?&#34;</span> <span style=color:#f92672>+</span> channel.<span style=color:#a6e22e>isOpen</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    doBeforeRpcHooks(ChannelUtil.<span style=color:#a6e22e>getAddressFromChannel</span>(channel), rpcMessage);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    channel.<span style=color:#a6e22e>writeAndFlush</span>(rpcMessage).<span style=color:#a6e22e>addListener</span>((ChannelFutureListener) future <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>future.<span style=color:#a6e22e>isSuccess</span>()) {
</span></span><span style=display:flex><span>            destroyChannel(future.<span style=color:#a6e22e>channel</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>只需要简单调用 channel 的 writeAndFlush 方法即可实现异步调用。</p><p>特别要注意的是，writeAndFlush 方法在调用线程是 EventLoop 线程的情况下会变成同步调用，核心的点在于 writeAndFlush 的行为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>EventExecutor executor <span style=color:#f92672>=</span> next.<span style=color:#a6e22e>executor</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (executor.<span style=color:#a6e22e>inEventLoop</span>()) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 同步执行</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (flush) {
</span></span><span style=display:flex><span>        next.<span style=color:#a6e22e>invokeWriteAndFlush</span>(m, promise);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        next.<span style=color:#a6e22e>invokeWrite</span>(m, promise);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 提交写任务</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> WriteTask task <span style=color:#f92672>=</span> WriteTask.<span style=color:#a6e22e>newInstance</span>(next, m, promise, flush);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>safeExecute(executor, task, promise, m, <span style=color:#f92672>!</span>flush)) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// We failed to submit the WriteTask. We need to cancel it so we decrement the pending bytes</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// and put it back in the Recycler for re-use later.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// See https://github.com/netty/netty/issues/8343.</span>
</span></span><span style=display:flex><span>        task.<span style=color:#a6e22e>cancel</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我这里再给出一段用于测试的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.fhj;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> io.netty.bootstrap.Bootstrap;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> io.netty.buffer.Unpooled;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> io.netty.channel.*;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> io.netty.channel.nio.NioEventLoopGroup;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> io.netty.channel.socket.SocketChannel;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> io.netty.channel.socket.nio.NioSocketChannel;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> io.netty.util.CharsetUtil;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> lombok.extern.slf4j.Slf4j;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Slf4j</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NettyWriteBehaviorDemo</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        EventLoopGroup group <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> NioEventLoopGroup(1);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            Bootstrap bootstrap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Bootstrap()
</span></span><span style=display:flex><span>                    .<span style=color:#a6e22e>group</span>(group)
</span></span><span style=display:flex><span>                    .<span style=color:#a6e22e>channel</span>(NioSocketChannel.<span style=color:#a6e22e>class</span>)
</span></span><span style=display:flex><span>                    .<span style=color:#a6e22e>handler</span>(<span style=color:#66d9ef>new</span> ChannelInitializer<span style=color:#f92672>&lt;</span>SocketChannel<span style=color:#f92672>&gt;</span>() {
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initChannel</span>(SocketChannel ch) {
</span></span><span style=display:flex><span>                            ch.<span style=color:#a6e22e>pipeline</span>().<span style=color:#a6e22e>addLast</span>(<span style=color:#66d9ef>new</span> SimpleChannelInboundHandler<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span>() {
</span></span><span style=display:flex><span>                                <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>channelRead0</span>(ChannelHandlerContext ctx, Object msg) {
</span></span><span style=display:flex><span>                                    log.<span style=color:#a6e22e>debug</span>(<span style=color:#e6db74>&#34;收到服务器响应: {}&#34;</span>, msg);
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                                <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>channelActive</span>(ChannelHandlerContext ctx) {
</span></span><span style=display:flex><span>                                    log.<span style=color:#a6e22e>debug</span>(<span style=color:#e6db74>&#34;通道已激活&#34;</span>);
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                            });
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Channel channel <span style=color:#f92672>=</span> bootstrap.<span style=color:#a6e22e>connect</span>(<span style=color:#e6db74>&#34;localhost&#34;</span>, 8080).<span style=color:#a6e22e>sync</span>().<span style=color:#a6e22e>channel</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 场景1：在 EventLoop 线程中调用（同步）</span>
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;\n=== 在 EventLoop 线程中调用 ===&#34;</span>);
</span></span><span style=display:flex><span>            channel.<span style=color:#a6e22e>eventLoop</span>().<span style=color:#a6e22e>execute</span>(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;调用线程: {}&#34;</span>, Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>long</span> start <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>nanoTime</span>();
</span></span><span style=display:flex><span>                ChannelFuture future <span style=color:#f92672>=</span> channel.<span style=color:#a6e22e>writeAndFlush</span>(
</span></span><span style=display:flex><span>                        Unpooled.<span style=color:#a6e22e>copiedBuffer</span>(<span style=color:#e6db74>&#34;EventLoop线程写入&#34;</span>, CharsetUtil.<span style=color:#a6e22e>UTF_8</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>long</span> duration <span style=color:#f92672>=</span> (System.<span style=color:#a6e22e>nanoTime</span>() <span style=color:#f92672>-</span> start) <span style=color:#f92672>/</span> 1000;
</span></span><span style=display:flex><span>                log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;写入耗时: {} 微秒&#34;</span>, duration);
</span></span><span style=display:flex><span>                log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;操作是否完成: {}&#34;</span>, future.<span style=color:#a6e22e>isDone</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 添加监听器验证完成状态</span>
</span></span><span style=display:flex><span>                future.<span style=color:#a6e22e>addListener</span>(f <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                        log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;监听器触发线程: {}&#34;</span>, Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>())
</span></span><span style=display:flex><span>                );
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 等待第一个场景执行完成</span>
</span></span><span style=display:flex><span>            Thread.<span style=color:#a6e22e>sleep</span>(500);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 场景2：在非 EventLoop 线程中调用（异步）</span>
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;\n=== 在非 EventLoop 线程中调用 ===&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;调用线程: {}&#34;</span>, Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>long</span> start <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>nanoTime</span>();
</span></span><span style=display:flex><span>                ChannelFuture future <span style=color:#f92672>=</span> channel.<span style=color:#a6e22e>writeAndFlush</span>(
</span></span><span style=display:flex><span>                        Unpooled.<span style=color:#a6e22e>copiedBuffer</span>(<span style=color:#e6db74>&#34;非EventLoop线程写入&#34;</span>, CharsetUtil.<span style=color:#a6e22e>UTF_8</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>long</span> duration <span style=color:#f92672>=</span> (System.<span style=color:#a6e22e>nanoTime</span>() <span style=color:#f92672>-</span> start) <span style=color:#f92672>/</span> 1000;
</span></span><span style=display:flex><span>                log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;写入耗时: {} 微秒&#34;</span>, duration);
</span></span><span style=display:flex><span>                log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;操作是否完成: {}&#34;</span>, future.<span style=color:#a6e22e>isDone</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 添加监听器确认异步完成</span>
</span></span><span style=display:flex><span>                future.<span style=color:#a6e22e>addListener</span>(f <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                        log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;异步完成确认线程: {}&#34;</span>, Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>())
</span></span><span style=display:flex><span>                );
</span></span><span style=display:flex><span>            }, <span style=color:#e6db74>&#34;BusinessThread-1&#34;</span>).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Thread.<span style=color:#a6e22e>sleep</span>(1500); <span style=color:#75715e>// 等待操作完成</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>            group.<span style=color:#a6e22e>shutdownGracefully</span>().<span style=color:#a6e22e>sync</span>();
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Netty客户端已关闭&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=同步调用>同步调用</h3><p>在 Netty 中实现异步调用很简单，要实现同步调用就麻烦一点，需要将异步调用转换为同步调用。</p><p>从本质上来说，异步转同步就是让调用线程发起调用后，在拿到响应前进入阻塞，拿到响应后再唤醒，向下执行。</p><p>那么 Seata 的处理的核心就是 MessageFuture 类，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> org.apache.seata.core.protocol;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.seata.common.exception.ShouldNeverHappenException;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.CompletableFuture;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.ExecutionException;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.TimeUnit;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.TimeoutException;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MessageFuture</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> RpcMessage requestMessage;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>long</span> timeout;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>long</span> start <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>transient</span> CompletableFuture<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> origin <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CompletableFuture<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isTimeout</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> System.<span style=color:#a6e22e>currentTimeMillis</span>() <span style=color:#f92672>-</span> start <span style=color:#f92672>&gt;</span> timeout;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>get</span>(<span style=color:#66d9ef>long</span> timeout, TimeUnit unit) <span style=color:#66d9ef>throws</span> TimeoutException, InterruptedException {
</span></span><span style=display:flex><span>        Object result <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            result <span style=color:#f92672>=</span> origin.<span style=color:#a6e22e>get</span>(timeout, unit);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (result <span style=color:#66d9ef>instanceof</span> TimeoutException) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> (TimeoutException) result;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (ExecutionException e) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ShouldNeverHappenException(<span style=color:#e6db74>&#34;Should not get results in a multi-threaded environment&#34;</span>, e);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (TimeoutException e) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> TimeoutException(
</span></span><span style=display:flex><span>                    String.<span style=color:#a6e22e>format</span>(<span style=color:#e6db74>&#34;%s ,cost: %d ms&#34;</span>, e.<span style=color:#a6e22e>getMessage</span>(), System.<span style=color:#a6e22e>currentTimeMillis</span>() <span style=color:#f92672>-</span> start));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (result <span style=color:#66d9ef>instanceof</span> RuntimeException) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> (RuntimeException) result;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (result <span style=color:#66d9ef>instanceof</span> Throwable) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException((Throwable) result);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setResultMessage</span>(Object obj) {
</span></span><span style=display:flex><span>        origin.<span style=color:#a6e22e>complete</span>(obj);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>有了这个 MessageFuture 之后，我们再来看 sendSync 的基础实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>protected</span> Object <span style=color:#a6e22e>sendSync</span>(Channel channel, RpcMessage rpcMessage, <span style=color:#66d9ef>long</span> timeoutMillis) <span style=color:#66d9ef>throws</span> TimeoutException {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (timeoutMillis <span style=color:#f92672>&lt;=</span> 0) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> FrameworkException(<span style=color:#e6db74>&#34;timeout should more than 0ms&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (channel <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        LOGGER.<span style=color:#a6e22e>warn</span>(<span style=color:#e6db74>&#34;sendSync nothing, caused by null channel.&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (MsgVersionHelper.<span style=color:#a6e22e>versionNotSupport</span>(channel, rpcMessage)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (LOGGER.<span style=color:#a6e22e>isDebugEnabled</span>()) {
</span></span><span style=display:flex><span>            LOGGER.<span style=color:#a6e22e>debug</span>(
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#34;Message sending will be skipped as the client version does not support it,{}&#34;</span>, rpcMessage);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> VersionNotSupportMessage();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    MessageFuture messageFuture <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MessageFuture();
</span></span><span style=display:flex><span>    messageFuture.<span style=color:#a6e22e>setRequestMessage</span>(rpcMessage);
</span></span><span style=display:flex><span>    messageFuture.<span style=color:#a6e22e>setTimeout</span>(timeoutMillis);
</span></span><span style=display:flex><span>    futures.<span style=color:#a6e22e>put</span>(rpcMessage.<span style=color:#a6e22e>getId</span>(), messageFuture);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 检查该 Channel 是否可写（Channel 中有写缓冲区，如果缓冲区达到写阈值水位，则不可写）</span>
</span></span><span style=display:flex><span>    channelWritableCheck(channel, rpcMessage.<span style=color:#a6e22e>getBody</span>());
</span></span><span style=display:flex><span>    String remoteAddr <span style=color:#f92672>=</span> ChannelUtil.<span style=color:#a6e22e>getAddressFromChannel</span>(channel);
</span></span><span style=display:flex><span>    doBeforeRpcHooks(remoteAddr, rpcMessage);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 发送结果，并设置回调，这里还是非阻塞、异步的</span>
</span></span><span style=display:flex><span>    channel.<span style=color:#a6e22e>writeAndFlush</span>(rpcMessage).<span style=color:#a6e22e>addListener</span>((ChannelFutureListener) future <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>future.<span style=color:#a6e22e>isSuccess</span>()) {
</span></span><span style=display:flex><span>            MessageFuture mf <span style=color:#f92672>=</span> futures.<span style=color:#a6e22e>remove</span>(rpcMessage.<span style=color:#a6e22e>getId</span>());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (mf <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                mf.<span style=color:#a6e22e>setResultMessage</span>(future.<span style=color:#a6e22e>cause</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            destroyChannel(future.<span style=color:#a6e22e>channel</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 在这里等待结果，是异步转为同步的关键</span>
</span></span><span style=display:flex><span>        Object result <span style=color:#f92672>=</span> messageFuture.<span style=color:#a6e22e>get</span>(timeoutMillis, TimeUnit.<span style=color:#a6e22e>MILLISECONDS</span>);
</span></span><span style=display:flex><span>        doAfterRpcHooks(remoteAddr, rpcMessage, result);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Exception exx) {
</span></span><span style=display:flex><span>        LOGGER.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;wait response error:{},ip:{},request:{}&#34;</span>, exx.<span style=color:#a6e22e>getMessage</span>(), channel.<span style=color:#a6e22e>remoteAddress</span>(), rpcMessage.<span style=color:#a6e22e>getBody</span>());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (exx <span style=color:#66d9ef>instanceof</span> TimeoutException) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> (TimeoutException) exx;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(exx);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在该方法中，还有一个关键的属性：futures</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Obtain the return result through MessageFuture blocking.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @see AbstractNettyRemoting#sendSync
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>final</span> ConcurrentHashMap<span style=color:#f92672>&lt;</span>Integer, MessageFuture<span style=color:#f92672>&gt;</span> futures <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConcurrentHashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span></code></pre></div><p>它用于存储尚未完成的 RPC 请求，这个 map 的 key 是用于唯一标识每一个请求/响应的 id。</p><p>基于以上铺垫，那么同步调用的过程如下，我们以服务端请求、客户端响应为例：</p><ul><li>首先服务端将 RPC 请求构建为 MessageFuture，并生成唯一请求 id，然后将请求 id 和该 MessageFuture 存储到 futures 中。</li><li>接着服务端调用 channel.writeAndFlush 发起异步调用，是的，这里还是异步。</li><li>异步转同步的核心在于，此时服务端线程需要调用 MessageFuture.get() 进入阻塞，当然实际是调用了 CompletableFuture.get() 进入阻塞。</li><li>当客户端处理请求完毕之后，它就会构建然后发出响应，该条响应的唯一 id 一定和请求 id 是相同的。</li><li>当服务端收到响应之后，就会由某个线程将响应结果设置到 MessageFuture 中，由于一次请求和响应的 id 是相同的，所以可以从上面的哈希表中拿到相应的 MessageFuture 对象。</li><li>当响应结果被设置之后，最初阻塞在 get 方法的线程就可以恢复运行，这样就实现了同步的效果。</li></ul><p>所以，Seata 的解决方案本质上来说就是利用了 CompletableFuture 对象，将它作为一个存储结果的容器。</p><p>此外，服务端处理客户端响应的逻辑在 ServerOnResponseProcessor 类中，执行的线程是 branchResultMessageExecutor 中的线程。</p><p>为什么我会肯定一次 RPC 的请求和响应的唯一 id 一定是相同的呢？首先逻辑上一定是这样，不然怎么设置结果到 MessageFuture 呢，其次就是构建请求和响应的代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>protected</span> RpcMessage <span style=color:#a6e22e>buildRequestMessage</span>(Object msg, <span style=color:#66d9ef>byte</span> messageType) {
</span></span><span style=display:flex><span>    RpcMessage rpcMessage <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> RpcMessage();
</span></span><span style=display:flex><span>    rpcMessage.<span style=color:#a6e22e>setId</span>(getNextMessageId());
</span></span><span style=display:flex><span>    rpcMessage.<span style=color:#a6e22e>setMessageType</span>(messageType);
</span></span><span style=display:flex><span>    rpcMessage.<span style=color:#a6e22e>setCodec</span>(ProtocolConstants.<span style=color:#a6e22e>CONFIGURED_CODEC</span>);
</span></span><span style=display:flex><span>    rpcMessage.<span style=color:#a6e22e>setCompressor</span>(ProtocolConstants.<span style=color:#a6e22e>CONFIGURED_COMPRESSOR</span>);
</span></span><span style=display:flex><span>    rpcMessage.<span style=color:#a6e22e>setBody</span>(msg);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> rpcMessage;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> RpcMessage <span style=color:#a6e22e>buildResponseMessage</span>(RpcMessage rpcMessage, Object msg, <span style=color:#66d9ef>byte</span> messageType) {
</span></span><span style=display:flex><span>    RpcMessage rpcMsg <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> RpcMessage();
</span></span><span style=display:flex><span>    rpcMsg.<span style=color:#a6e22e>setMessageType</span>(messageType);
</span></span><span style=display:flex><span>    rpcMsg.<span style=color:#a6e22e>setCodec</span>(rpcMessage.<span style=color:#a6e22e>getCodec</span>());
</span></span><span style=display:flex><span>    rpcMsg.<span style=color:#a6e22e>setCompressor</span>(rpcMessage.<span style=color:#a6e22e>getCompressor</span>());
</span></span><span style=display:flex><span>    rpcMsg.<span style=color:#a6e22e>setBody</span>(msg);
</span></span><span style=display:flex><span>    rpcMsg.<span style=color:#a6e22e>setId</span>(rpcMessage.<span style=color:#a6e22e>getId</span>()); <span style=color:#75715e>// 一次 RPC 的请求和响应的唯一 id 一定是相同</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> rpcMsg;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=报文处理>报文处理</h3><p>在 Netty 中，提到报文处理，我们首先应该想到的就是入栈、出栈处理器。</p><p>在 Seata Server 端，除了常见的编解码处理器之外，就是 ServerHandler 处理器了，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.apache.seata.core.rpc.netty.AbstractNettyRemotingServer.ServerHandler</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@ChannelHandler.Sharable</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ServerHandler</span> <span style=color:#66d9ef>extends</span> ChannelDuplexHandler {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>channelRead</span>(<span style=color:#66d9ef>final</span> ChannelHandlerContext ctx, Object msg) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 前置了解码处理器，所以这里的消息是 RpcMessage</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (msg <span style=color:#66d9ef>instanceof</span> RpcMessage) {
</span></span><span style=display:flex><span>            processMessage(ctx, (RpcMessage) msg);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            LOGGER.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;rpcMessage type error&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>比较有业务含义的就是这个 channelRead 方法，所有请求至 Server 的报文在经过解码之后都会来到这个方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>processMessage</span>(ChannelHandlerContext ctx, RpcMessage rpcMessage) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>    Object body <span style=color:#f92672>=</span> rpcMessage.<span style=color:#a6e22e>getBody</span>();
</span></span><span style=display:flex><span>    RpcContext rpcContext <span style=color:#f92672>=</span> ChannelManager.<span style=color:#a6e22e>getContextFromIdentified</span>(ctx.<span style=color:#a6e22e>channel</span>());
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If the client is not version 2.3.0 or higher, splitting MergedWarpMessage will result in the client’s</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// mergeMsgMap not being cleared</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (body <span style=color:#66d9ef>instanceof</span> MergedWarpMessage
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> (StringUtils.<span style=color:#a6e22e>isNotBlank</span>(rpcContext.<span style=color:#a6e22e>getVersion</span>())
</span></span><span style=display:flex><span>                    <span style=color:#f92672>&amp;&amp;</span> Version.<span style=color:#a6e22e>isAboveOrEqualVersion230</span>(rpcContext.<span style=color:#a6e22e>getVersion</span>()))) {
</span></span><span style=display:flex><span>        MergedWarpMessage mergedWarpMessage <span style=color:#f92672>=</span> (MergedWarpMessage) body;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> mergedWarpMessage.<span style=color:#a6e22e>msgs</span>.<span style=color:#a6e22e>size</span>(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            RpcMessage rpcMsg <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>                    buildRequestMessage(mergedWarpMessage.<span style=color:#a6e22e>msgs</span>.<span style=color:#a6e22e>get</span>(i), rpcMessage, mergedWarpMessage.<span style=color:#a6e22e>msgIds</span>.<span style=color:#a6e22e>get</span>(i));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>processMessage</span>(ctx, rpcMsg);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>processMessage</span>(ctx, rpcMessage);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里的 super.processMessage 方法就是 AbstractNettyRemoting 中的业务处理方法，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>processMessage</span>(ChannelHandlerContext ctx, RpcMessage rpcMessage) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (LOGGER.<span style=color:#a6e22e>isDebugEnabled</span>()) {
</span></span><span style=display:flex><span>        LOGGER.<span style=color:#a6e22e>debug</span>(String.<span style=color:#a6e22e>format</span>(<span style=color:#e6db74>&#34;%s msgId:%s, body:%s&#34;</span>, <span style=color:#66d9ef>this</span>, rpcMessage.<span style=color:#a6e22e>getId</span>(), rpcMessage.<span style=color:#a6e22e>getBody</span>()));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Object body <span style=color:#f92672>=</span> rpcMessage.<span style=color:#a6e22e>getBody</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (body <span style=color:#66d9ef>instanceof</span> MessageTypeAware) {
</span></span><span style=display:flex><span>        MessageTypeAware messageTypeAware <span style=color:#f92672>=</span> (MessageTypeAware) body;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 在 Server 启动的时候，向 processorTable 注册了一大堆处理器，这里通过消息 Code 拿到对应的处理器和执行器</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> Pair<span style=color:#f92672>&lt;</span>RemotingProcessor, ExecutorService<span style=color:#f92672>&gt;</span> pair <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>processorTable</span>.<span style=color:#a6e22e>get</span>((<span style=color:#66d9ef>int</span>) messageTypeAware.<span style=color:#a6e22e>getTypeCode</span>());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (pair <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 拿到对应的线程池执行</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (pair.<span style=color:#a6e22e>getSecond</span>() <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    pair.<span style=color:#a6e22e>getSecond</span>().<span style=color:#a6e22e>execute</span>(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// 找对应的处理器执行</span>
</span></span><span style=display:flex><span>                            pair.<span style=color:#a6e22e>getFirst</span>().<span style=color:#a6e22e>process</span>(ctx, rpcMessage);
</span></span><span style=display:flex><span>                        } <span style=color:#66d9ef>catch</span> (Throwable th) {
</span></span><span style=display:flex><span>                            LOGGER.<span style=color:#a6e22e>error</span>(FrameworkErrorCode.<span style=color:#a6e22e>NetDispatch</span>.<span style=color:#a6e22e>getErrCode</span>(), th.<span style=color:#a6e22e>getMessage</span>(), th);
</span></span><span style=display:flex><span>                        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                            MDC.<span style=color:#a6e22e>clear</span>();
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    });
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (RejectedExecutionException e) {
</span></span><span style=display:flex><span>                    LOGGER.<span style=color:#a6e22e>error</span>(
</span></span><span style=display:flex><span>                            FrameworkErrorCode.<span style=color:#a6e22e>ThreadPoolFull</span>.<span style=color:#a6e22e>getErrCode</span>(),
</span></span><span style=display:flex><span>                            <span style=color:#e6db74>&#34;thread pool is full, current max pool size is &#34;</span> <span style=color:#f92672>+</span> messageExecutor.<span style=color:#a6e22e>getActiveCount</span>());
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (allowDumpStack) {
</span></span><span style=display:flex><span>                        String name <span style=color:#f92672>=</span> ManagementFactory.<span style=color:#a6e22e>getRuntimeMXBean</span>().<span style=color:#a6e22e>getName</span>();
</span></span><span style=display:flex><span>                        String pid <span style=color:#f92672>=</span> name.<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#34;@&#34;</span>)<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>long</span> idx <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>();
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                            String jstackFile <span style=color:#f92672>=</span> idx <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;.log&#34;</span>;
</span></span><span style=display:flex><span>                            LOGGER.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;jstack command will dump to &#34;</span> <span style=color:#f92672>+</span> jstackFile);
</span></span><span style=display:flex><span>                            Runtime.<span style=color:#a6e22e>getRuntime</span>().<span style=color:#a6e22e>exec</span>(String.<span style=color:#a6e22e>format</span>(<span style=color:#e6db74>&#34;jstack %s &gt; %s&#34;</span>, pid, jstackFile));
</span></span><span style=display:flex><span>                        } <span style=color:#66d9ef>catch</span> (IOException exx) {
</span></span><span style=display:flex><span>                            LOGGER.<span style=color:#a6e22e>error</span>(exx.<span style=color:#a6e22e>getMessage</span>());
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        allowDumpStack <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 如果没有为处理器配置线程池，则由当前线程执行，基本上就是 EventLoop 线程了</span>
</span></span><span style=display:flex><span>                    pair.<span style=color:#a6e22e>getFirst</span>().<span style=color:#a6e22e>process</span>(ctx, rpcMessage);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (Throwable th) {
</span></span><span style=display:flex><span>                    LOGGER.<span style=color:#a6e22e>error</span>(FrameworkErrorCode.<span style=color:#a6e22e>NetDispatch</span>.<span style=color:#a6e22e>getErrCode</span>(), th.<span style=color:#a6e22e>getMessage</span>(), th);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            LOGGER.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;This message type [{}] has no processor.&#34;</span>, messageTypeAware.<span style=color:#a6e22e>getTypeCode</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        LOGGER.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;This rpcMessage body[{}] is not MessageTypeAware type.&#34;</span>, body);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个方法的逻辑很简单。</p><p>Seata 在 Server 启动的过程中，向 processorTable 注册了一大堆处理器，那么这里就可以根据消息 Code 拿到对应的处理器和线程池。</p><p>如果有线程池，就在线程池内执行处理器的方法，否则就交给 EventLoop 线程去执行。</p><p>当然，对于 Client 而言，也是这样的。</p><h3 id=批量发送>批量发送</h3><p>在网络程序中，有时候也需要实现批量发送，在 Seata 中，目前只有客户端批量发送请求到服务端的场景。</p><p>还记得我们上面在 Client 启动的过程中提到过一个线程池 mergeSendExecutorService，如果允许批量发送，那么在 Client 启动的时候就会提交一个 MergedSendRunnable 任务，我们先来看这个任务在干啥？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MergedSendRunnable</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>synchronized</span> (mergeLock) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    mergeLock.<span style=color:#a6e22e>wait</span>(MAX_MERGE_SEND_MILLS); <span style=color:#75715e>// 解决 CPU 高负载问题</span>
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (InterruptedException ignore) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// ignore</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            isSending <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// basketMap: key 是 serverAddress，value 是发向该 serverAddress 的报文队列（阻塞队列）</span>
</span></span><span style=display:flex><span>            basketMap.<span style=color:#a6e22e>forEach</span>((address, basket) <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (basket.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                MergedWarpMessage mergeMessage <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MergedWarpMessage();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>basket.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 将同一个阻塞队列中所有 RpcMessage 进行合并</span>
</span></span><span style=display:flex><span>                    RpcMessage msg <span style=color:#f92672>=</span> basket.<span style=color:#a6e22e>poll</span>();
</span></span><span style=display:flex><span>                    mergeMessage.<span style=color:#a6e22e>msgs</span>.<span style=color:#a6e22e>add</span>((AbstractMessage) msg.<span style=color:#a6e22e>getBody</span>());
</span></span><span style=display:flex><span>                    mergeMessage.<span style=color:#a6e22e>msgIds</span>.<span style=color:#a6e22e>add</span>(msg.<span style=color:#a6e22e>getId</span>());
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (mergeMessage.<span style=color:#a6e22e>msgIds</span>.<span style=color:#a6e22e>size</span>() <span style=color:#f92672>&gt;</span> 1) {
</span></span><span style=display:flex><span>                    printMergeMessageLog(mergeMessage);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                Channel sendChannel <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    sendChannel <span style=color:#f92672>=</span> clientChannelManager.<span style=color:#a6e22e>acquireChannel</span>(address);
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 内部将 mergeMessage 封装为一个普通的 RpcMessage 发送</span>
</span></span><span style=display:flex><span>                    AbstractNettyRemotingClient.<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>sendAsyncRequest</span>(sendChannel, mergeMessage);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (FrameworkException e) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (e.<span style=color:#a6e22e>getErrorCode</span>() <span style=color:#f92672>==</span> FrameworkErrorCode.<span style=color:#a6e22e>ChannelIsNotWritable</span> <span style=color:#f92672>&amp;&amp;</span> sendChannel <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                        destroyChannel(address, sendChannel);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// fast fail</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> (Integer msgId : mergeMessage.<span style=color:#a6e22e>msgIds</span>) {
</span></span><span style=display:flex><span>                        MessageFuture messageFuture <span style=color:#f92672>=</span> futures.<span style=color:#a6e22e>remove</span>(msgId);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (messageFuture <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                            messageFuture.<span style=color:#a6e22e>setResultMessage</span>(<span style=color:#66d9ef>new</span> RuntimeException(String.<span style=color:#a6e22e>format</span>(<span style=color:#e6db74>&#34;%s is unreachable&#34;</span>, address), e));
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    LOGGER.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;client merge call failed: {}&#34;</span>, e.<span style=color:#a6e22e>getMessage</span>(), e);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>            isSending <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>那么，与之相关的批量发送代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>sendSyncRequest</span>(Object msg) <span style=color:#66d9ef>throws</span> TimeoutException {
</span></span><span style=display:flex><span>    String serverAddress <span style=color:#f92672>=</span> loadBalance(getTransactionServiceGroup(), msg);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>long</span> timeoutMillis <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>getRpcRequestTimeout</span>();
</span></span><span style=display:flex><span>    RpcMessage rpcMessage <span style=color:#f92672>=</span> buildRequestMessage(msg, ProtocolConstants.<span style=color:#a6e22e>MSGTYPE_RESQUEST_SYNC</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// send batch message</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// put message into basketMap, @see MergedSendRunnable</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>isEnableClientBatchSendRequest</span>()) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// send batch message is sync request, needs to create messageFuture and put it in futures.</span>
</span></span><span style=display:flex><span>        MessageFuture messageFuture <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MessageFuture();
</span></span><span style=display:flex><span>        messageFuture.<span style=color:#a6e22e>setRequestMessage</span>(rpcMessage);
</span></span><span style=display:flex><span>        messageFuture.<span style=color:#a6e22e>setTimeout</span>(timeoutMillis);
</span></span><span style=display:flex><span>        futures.<span style=color:#a6e22e>put</span>(rpcMessage.<span style=color:#a6e22e>getId</span>(), messageFuture);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// put message into basketMap</span>
</span></span><span style=display:flex><span>        BlockingQueue<span style=color:#f92672>&lt;</span>RpcMessage<span style=color:#f92672>&gt;</span> basket <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>                CollectionUtils.<span style=color:#a6e22e>computeIfAbsent</span>(basketMap, serverAddress, key <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>new</span> LinkedBlockingQueue<span style=color:#f92672>&lt;&gt;</span>());
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将 rpcMessage 添加到队列中，等待 mergeSendExecutorService 进行实际的发送</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>basket.<span style=color:#a6e22e>offer</span>(rpcMessage)) {
</span></span><span style=display:flex><span>            LOGGER.<span style=color:#a6e22e>error</span>(
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#34;put message into basketMap offer failed, serverAddress:{},rpcMessage:{}&#34;</span>,
</span></span><span style=display:flex><span>                    serverAddress,
</span></span><span style=display:flex><span>                    rpcMessage);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (LOGGER.<span style=color:#a6e22e>isDebugEnabled</span>()) {
</span></span><span style=display:flex><span>            LOGGER.<span style=color:#a6e22e>debug</span>(<span style=color:#e6db74>&#34;offer message: {}&#34;</span>, rpcMessage.<span style=color:#a6e22e>getBody</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isSending) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 保证队列中一有数据，就唤醒线程，进行批量发送</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>synchronized</span> (mergeLock) {
</span></span><span style=display:flex><span>                mergeLock.<span style=color:#a6e22e>notifyAll</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            Object response <span style=color:#f92672>=</span> messageFuture.<span style=color:#a6e22e>get</span>(timeoutMillis, TimeUnit.<span style=color:#a6e22e>MILLISECONDS</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> response;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception exx) {
</span></span><span style=display:flex><span>            LOGGER.<span style=color:#a6e22e>error</span>(
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#34;wait response error:{},ip:{},request:{}&#34;</span>,
</span></span><span style=display:flex><span>                    exx.<span style=color:#a6e22e>getMessage</span>(),
</span></span><span style=display:flex><span>                    serverAddress,
</span></span><span style=display:flex><span>                    rpcMessage.<span style=color:#a6e22e>getBody</span>());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (exx <span style=color:#66d9ef>instanceof</span> TimeoutException) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> (TimeoutException) exx;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(exx);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 普通发送，拿到 channel 调父类的 sendSync 方法即可</span>
</span></span><span style=display:flex><span>        Channel channel <span style=color:#f92672>=</span> clientChannelManager.<span style=color:#a6e22e>acquireChannel</span>(serverAddress);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>sendSync</span>(channel, rpcMessage, timeoutMillis);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到，这里面也用到了对象锁的同步-等待机制，那么实现的效果就是：</p><ol><li>最多隔 1ms 会遍历 basketMap 进行报文发送。</li><li>在 mergeSendExecutorService 内部的线程阻塞期间（mainLock.wait），如果来了需要发送的报文，那么会唤醒 mainLock 上的线程，继续进行发送。</li></ol><p>那 Server 是怎么处理的呢？主要看 MergedWarpMessage 报文的 TypeCode，实际上就是 TYPE_SEATA_MERGE，再看 Server 启动的时候对这个 Code 注册哪个处理器，实际上就是 ServerOnRequestProcessor。</p><p>在 ServerOnRequestProcessor 这边，实际上对应了两种处理 MergedWarpMessage 报文的方式：</p><ol><li>MergedWarpMessage 中的所有独立请求全部处理完毕之后，统一发送 MergeResultMessage。</li><li>由 batchResponseExecutorService 线程池处理发送任务，可以保证两点，一是当有报文结果就响应，即使线程 wait，也会将它 notify，二是至少 1ms 会响应一次，因为 batchResponseExecutorService 中执行的线程最多 wait 1ms。这个 1ms 我本来以为是要保证响应的及时性，后面看了代码提交记录才发现这是为了解决 CPU 高负载的问题。</li></ol><p>注意，这两种方式响应的报文类型是不同的，第一种响应的是 MergeResultMessage，第二种是 BatchResultMessage，在 Client 也会有不同的处理。</p><p>ServerOnRequestProcessor 中核心处理方法如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onRequestMessage</span>(ChannelHandlerContext ctx, RpcMessage rpcMessage) {
</span></span><span style=display:flex><span>    Object message <span style=color:#f92672>=</span> rpcMessage.<span style=color:#a6e22e>getBody</span>();
</span></span><span style=display:flex><span>    RpcContext rpcContext <span style=color:#f92672>=</span> ChannelManager.<span style=color:#a6e22e>getContextFromIdentified</span>(ctx.<span style=color:#a6e22e>channel</span>());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(message <span style=color:#66d9ef>instanceof</span> AbstractMessage)) {
</span></span><span style=display:flex><span>        LOGGER.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;unrecognized message:{}&#34;</span>, message);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// the batch send request message</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//  允许 TcServer 批量发送响应 &amp;&amp; 客户端版本号 &gt;= 1.5.0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (message <span style=color:#66d9ef>instanceof</span> MergedWarpMessage) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (NettyServerConfig.<span style=color:#a6e22e>isEnableTcServerBatchSendResponse</span>()
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;&amp;</span> StringUtils.<span style=color:#a6e22e>isNotBlank</span>(rpcContext.<span style=color:#a6e22e>getVersion</span>())
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;&amp;</span> Version.<span style=color:#a6e22e>isAboveOrEqualVersion150</span>(rpcContext.<span style=color:#a6e22e>getVersion</span>())) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 由 batchResponseExecutorService 单独处理，无需等到批量请求全部处理完毕</span>
</span></span><span style=display:flex><span>            List<span style=color:#f92672>&lt;</span>AbstractMessage<span style=color:#f92672>&gt;</span> msgs <span style=color:#f92672>=</span> ((MergedWarpMessage) message).<span style=color:#a6e22e>msgs</span>;
</span></span><span style=display:flex><span>            List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> msgIds <span style=color:#f92672>=</span> ((MergedWarpMessage) message).<span style=color:#a6e22e>msgIds</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> msgs.<span style=color:#a6e22e>size</span>(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                AbstractMessage msg <span style=color:#f92672>=</span> msgs.<span style=color:#a6e22e>get</span>(i);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> msgId <span style=color:#f92672>=</span> msgIds.<span style=color:#a6e22e>get</span>(i);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (PARALLEL_REQUEST_HANDLE) {
</span></span><span style=display:flex><span>                    CompletableFuture.<span style=color:#a6e22e>runAsync</span>(
</span></span><span style=display:flex><span>                            () <span style=color:#f92672>-&gt;</span> handleRequestsByMergedWarpMessageBy150(msg, msgId, rpcMessage, ctx, rpcContext));
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    handleRequestsByMergedWarpMessageBy150(msg, msgId, rpcMessage, ctx, rpcContext);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 每个请求都处理完毕，才能向客户端发出响应</span>
</span></span><span style=display:flex><span>            List<span style=color:#f92672>&lt;</span>AbstractResultMessage<span style=color:#f92672>&gt;</span> results <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>            List<span style=color:#f92672>&lt;</span>CompletableFuture<span style=color:#f92672>&lt;</span>AbstractResultMessage<span style=color:#f92672>&gt;&gt;</span> completableFutures <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> ((MergedWarpMessage) message).<span style=color:#a6e22e>msgs</span>.<span style=color:#a6e22e>size</span>(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (PARALLEL_REQUEST_HANDLE) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (completableFutures <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                        completableFutures <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>int</span> finalI <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>                    completableFutures.<span style=color:#a6e22e>add</span>(CompletableFuture.<span style=color:#a6e22e>supplyAsync</span>(() <span style=color:#f92672>-&gt;</span> handleRequestsByMergedWarpMessage(
</span></span><span style=display:flex><span>                            ((MergedWarpMessage) message).<span style=color:#a6e22e>msgs</span>.<span style=color:#a6e22e>get</span>(finalI), rpcContext)));
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    results.<span style=color:#a6e22e>add</span>(
</span></span><span style=display:flex><span>                            i,
</span></span><span style=display:flex><span>                            handleRequestsByMergedWarpMessage(
</span></span><span style=display:flex><span>                                    ((MergedWarpMessage) message).<span style=color:#a6e22e>msgs</span>.<span style=color:#a6e22e>get</span>(i), rpcContext));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (CollectionUtils.<span style=color:#a6e22e>isNotEmpty</span>(completableFutures)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> (CompletableFuture<span style=color:#f92672>&lt;</span>AbstractResultMessage<span style=color:#f92672>&gt;</span> completableFuture : completableFutures) {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// 需要等待每个请求处理完毕，在PARALLEL_REQUEST_HANDLE的情况下才有</span>
</span></span><span style=display:flex><span>                        results.<span style=color:#a6e22e>add</span>(completableFuture.<span style=color:#a6e22e>get</span>());
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (InterruptedException <span style=color:#f92672>|</span> ExecutionException e) {
</span></span><span style=display:flex><span>                    LOGGER.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;handle request error: {}&#34;</span>, e.<span style=color:#a6e22e>getMessage</span>(), e);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            MergeResultMessage resultMessage <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MergeResultMessage();
</span></span><span style=display:flex><span>            resultMessage.<span style=color:#a6e22e>setMsgs</span>(results.<span style=color:#a6e22e>toArray</span>(<span style=color:#66d9ef>new</span> AbstractResultMessage<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>));
</span></span><span style=display:flex><span>            remotingServer.<span style=color:#a6e22e>sendAsyncResponse</span>(rpcMessage, ctx.<span style=color:#a6e22e>channel</span>(), resultMessage);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>而 handleRequestsByMergedWarpMessage 和 handleRequestsByMergedWarpMessageBy150 的区别就在于后者会将结果封装为 QueueItem 加入阻塞队列由 batchResponseExecutorService 中的线程进行实际的发送，而前者仅仅是返回处理的结果。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> AbstractResultMessage <span style=color:#a6e22e>handleRequestsByMergedWarpMessage</span>(AbstractMessage subMessage, RpcContext rpcContext) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (LOGGER.<span style=color:#a6e22e>isInfoEnabled</span>()) {
</span></span><span style=display:flex><span>        String receiveMsgLog <span style=color:#f92672>=</span> String.<span style=color:#a6e22e>format</span>(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;receive msg[merged]: %s, clientIp: %s, vgroup: %s&#34;</span>,
</span></span><span style=display:flex><span>                subMessage,
</span></span><span style=display:flex><span>                NetUtil.<span style=color:#a6e22e>toIpAddress</span>(rpcContext.<span style=color:#a6e22e>getChannel</span>().<span style=color:#a6e22e>remoteAddress</span>()),
</span></span><span style=display:flex><span>                rpcContext.<span style=color:#a6e22e>getTransactionServiceGroup</span>());
</span></span><span style=display:flex><span>        BatchLogHandler.<span style=color:#a6e22e>INSTANCE</span>.<span style=color:#a6e22e>writeLog</span>(receiveMsgLog);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    AbstractResultMessage resultMessage <span style=color:#f92672>=</span> transactionMessageHandler.<span style=color:#a6e22e>onRequest</span>(subMessage, rpcContext);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (LOGGER.<span style=color:#a6e22e>isInfoEnabled</span>()) {
</span></span><span style=display:flex><span>        String resultMsgLog <span style=color:#f92672>=</span> String.<span style=color:#a6e22e>format</span>(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;result msg[merged]: %s, clientIp: %s, vgroup: %s&#34;</span>,
</span></span><span style=display:flex><span>                resultMessage,
</span></span><span style=display:flex><span>                NetUtil.<span style=color:#a6e22e>toIpAddress</span>(rpcContext.<span style=color:#a6e22e>getChannel</span>().<span style=color:#a6e22e>remoteAddress</span>()),
</span></span><span style=display:flex><span>                rpcContext.<span style=color:#a6e22e>getTransactionServiceGroup</span>());
</span></span><span style=display:flex><span>        BatchLogHandler.<span style=color:#a6e22e>INSTANCE</span>.<span style=color:#a6e22e>writeLog</span>(resultMsgLog);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> resultMessage;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleRequestsByMergedWarpMessageBy150</span>(AbstractMessage msg, <span style=color:#66d9ef>int</span> msgId, RpcMessage rpcMessage,
</span></span><span style=display:flex><span>                                                    ChannelHandlerContext ctx, RpcContext rpcContext) {
</span></span><span style=display:flex><span>    AbstractResultMessage resultMessage <span style=color:#f92672>=</span> transactionMessageHandler.<span style=color:#a6e22e>onRequest</span>(msg, rpcContext);
</span></span><span style=display:flex><span>    BlockingQueue<span style=color:#f92672>&lt;</span>QueueItem<span style=color:#f92672>&gt;</span> msgQueue <span style=color:#f92672>=</span> CollectionUtils.<span style=color:#a6e22e>computeIfAbsent</span>(basketMap, ctx.<span style=color:#a6e22e>channel</span>(), key <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>new</span> LinkedBlockingQueue<span style=color:#f92672>&lt;&gt;</span>());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>msgQueue.<span style=color:#a6e22e>offer</span>(<span style=color:#66d9ef>new</span> QueueItem(resultMessage, msgId, rpcMessage))) {
</span></span><span style=display:flex><span>        LOGGER.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;put message into basketMap offer failed, channel: {}, rpcMessage: {}, resultMessage: {}&#34;</span>, ctx.<span style=color:#a6e22e>channel</span>(), rpcMessage, resultMessage);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isResponding) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 保证队列中一有数据，就唤醒线程，进行批量发送</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span> (batchResponseLock) {
</span></span><span style=display:flex><span>            batchResponseLock.<span style=color:#a6e22e>notifyAll</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleRequestsByMergedWarpMessageBy150</span>(
</span></span><span style=display:flex><span>        AbstractMessage msg, <span style=color:#66d9ef>int</span> msgId, RpcMessage rpcMessage, ChannelHandlerContext ctx, RpcContext rpcContext) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (LOGGER.<span style=color:#a6e22e>isInfoEnabled</span>()) {
</span></span><span style=display:flex><span>        String receiveMsgLog <span style=color:#f92672>=</span> String.<span style=color:#a6e22e>format</span>(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;receive msg[merged]: %s, clientIp: %s, vgroup: %s&#34;</span>,
</span></span><span style=display:flex><span>                msg, NetUtil.<span style=color:#a6e22e>toIpAddress</span>(ctx.<span style=color:#a6e22e>channel</span>().<span style=color:#a6e22e>remoteAddress</span>()), rpcContext.<span style=color:#a6e22e>getTransactionServiceGroup</span>());
</span></span><span style=display:flex><span>        BatchLogHandler.<span style=color:#a6e22e>INSTANCE</span>.<span style=color:#a6e22e>writeLog</span>(receiveMsgLog);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    AbstractResultMessage resultMessage <span style=color:#f92672>=</span> transactionMessageHandler.<span style=color:#a6e22e>onRequest</span>(msg, rpcContext);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 拿到 channel 对应的发送队列</span>
</span></span><span style=display:flex><span>    BlockingQueue<span style=color:#f92672>&lt;</span>QueueItem<span style=color:#f92672>&gt;</span> msgQueue <span style=color:#f92672>=</span> computeIfAbsentMsgQueue(ctx.<span style=color:#a6e22e>channel</span>());
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将结果添加到队列中，等待 batchResponseExecutorService 线程池实际进行发送</span>
</span></span><span style=display:flex><span>    offerMsg(msgQueue, rpcMessage, resultMessage, msgId, ctx.<span style=color:#a6e22e>channel</span>());
</span></span><span style=display:flex><span>    notifyBatchRespondingThread();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (LOGGER.<span style=color:#a6e22e>isInfoEnabled</span>()) {
</span></span><span style=display:flex><span>        String resultMsgLog <span style=color:#f92672>=</span> String.<span style=color:#a6e22e>format</span>(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;result msg[merged]: %s, clientIp: %s, vgroup: %s&#34;</span>,
</span></span><span style=display:flex><span>                resultMessage,
</span></span><span style=display:flex><span>                NetUtil.<span style=color:#a6e22e>toIpAddress</span>(ctx.<span style=color:#a6e22e>channel</span>().<span style=color:#a6e22e>remoteAddress</span>()),
</span></span><span style=display:flex><span>                rpcContext.<span style=color:#a6e22e>getTransactionServiceGroup</span>());
</span></span><span style=display:flex><span>        BatchLogHandler.<span style=color:#a6e22e>INSTANCE</span>.<span style=color:#a6e22e>writeLog</span>(resultMsgLog);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>再来看 batchResponseExecutorService 线程池是怎么处理批量发送的任务的？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BatchResponseRunnable</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>synchronized</span> (batchResponseLock) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    batchResponseLock.<span style=color:#a6e22e>wait</span>(MAX_BATCH_RESPONSE_MILLS);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                    LOGGER.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;BatchResponseRunnable Interrupted error&#34;</span>, e);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            isResponding <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            basketMap.<span style=color:#a6e22e>forEach</span>((channel, msgQueue) <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (msgQueue.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 将队列中的响应封装为 BatchResultMessage，但是注意并不是将所有的响应报文一次发送出去</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 需要按照 [serialization,compressor,rpcMessageId,headMap] 进行分组，然后按组进行异步发送</span>
</span></span><span style=display:flex><span>                Map<span style=color:#f92672>&lt;</span>ClientRequestRpcInfo, BatchResultMessage<span style=color:#f92672>&gt;</span> batchResultMessageMap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>msgQueue.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>                    QueueItem item <span style=color:#f92672>=</span> msgQueue.<span style=color:#a6e22e>poll</span>();
</span></span><span style=display:flex><span>                    BatchResultMessage batchResultMessage <span style=color:#f92672>=</span> CollectionUtils.<span style=color:#a6e22e>computeIfAbsent</span>(
</span></span><span style=display:flex><span>                            batchResultMessageMap,
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>new</span> ClientRequestRpcInfo(item.<span style=color:#a6e22e>getRpcMessage</span>()),
</span></span><span style=display:flex><span>                            key <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>new</span> BatchResultMessage());
</span></span><span style=display:flex><span>                    batchResultMessage.<span style=color:#a6e22e>getResultMessages</span>().<span style=color:#a6e22e>add</span>(item.<span style=color:#a6e22e>getResultMessage</span>());
</span></span><span style=display:flex><span>                    batchResultMessage.<span style=color:#a6e22e>getMsgIds</span>().<span style=color:#a6e22e>add</span>(item.<span style=color:#a6e22e>getMsgId</span>());
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                batchResultMessageMap.<span style=color:#a6e22e>forEach</span>(
</span></span><span style=display:flex><span>                        (clientRequestRpcInfo, batchResultMessage) <span style=color:#f92672>-&gt;</span> remotingServer.<span style=color:#a6e22e>sendAsyncResponse</span>(
</span></span><span style=display:flex><span>                                buildRpcMessage(clientRequestRpcInfo), channel, batchResultMessage));
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>            isResponding <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>最后我们来看 Client 这边是怎么处理 Server 发出的批量响应报文的，MergeResultMessage 的类型 Code 是 TYPE_SEATA_MERGE_RESULT，而 BatchResultMessage 的类型 Code 是 TYPE_BATCH_RESULT_MSG，但是处理这两个消息的处理器都是 ClientOnResponseProcessor，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>process</span>(ChannelHandlerContext ctx, RpcMessage rpcMessage) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (rpcMessage.<span style=color:#a6e22e>getBody</span>() <span style=color:#66d9ef>instanceof</span> MergeResultMessage) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 处理 MergeResultMessage</span>
</span></span><span style=display:flex><span>        MergeResultMessage results <span style=color:#f92672>=</span> (MergeResultMessage) rpcMessage.<span style=color:#a6e22e>getBody</span>();
</span></span><span style=display:flex><span>        MergedWarpMessage mergeMessage <span style=color:#f92672>=</span> (MergedWarpMessage) mergeMsgMap.<span style=color:#a6e22e>remove</span>(rpcMessage.<span style=color:#a6e22e>getId</span>());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> mergeMessage.<span style=color:#a6e22e>msgs</span>.<span style=color:#a6e22e>size</span>(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> msgId <span style=color:#f92672>=</span> mergeMessage.<span style=color:#a6e22e>msgIds</span>.<span style=color:#a6e22e>get</span>(i);
</span></span><span style=display:flex><span>            MessageFuture future <span style=color:#f92672>=</span> futures.<span style=color:#a6e22e>remove</span>(msgId);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// The old version of the server will return MergeResultMessage, so it is necessary to remove the msgId</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// from the childToParentMap.</span>
</span></span><span style=display:flex><span>            childToParentMap.<span style=color:#a6e22e>remove</span>(msgId);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (future <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                LOGGER.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;msg: {} is not found in futures, result message: {}&#34;</span>, msgId, results.<span style=color:#a6e22e>getMsgs</span>()<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                future.<span style=color:#a6e22e>setResultMessage</span>(results.<span style=color:#a6e22e>getMsgs</span>()<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (rpcMessage.<span style=color:#a6e22e>getBody</span>() <span style=color:#66d9ef>instanceof</span> BatchResultMessage) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 处理 BatchResultMessage</span>
</span></span><span style=display:flex><span>        BatchResultMessage batchResultMessage <span style=color:#f92672>=</span> (BatchResultMessage) rpcMessage.<span style=color:#a6e22e>getBody</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> batchResultMessage.<span style=color:#a6e22e>getMsgIds</span>().<span style=color:#a6e22e>size</span>(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> msgId <span style=color:#f92672>=</span> batchResultMessage.<span style=color:#a6e22e>getMsgIds</span>().<span style=color:#a6e22e>get</span>(i);
</span></span><span style=display:flex><span>            MessageFuture future <span style=color:#f92672>=</span> futures.<span style=color:#a6e22e>remove</span>(msgId);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// The old version of the server will return BatchResultMessage, so it is necessary to remove the msgId</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// from the childToParentMap.</span>
</span></span><span style=display:flex><span>            Integer parentId <span style=color:#f92672>=</span> childToParentMap.<span style=color:#a6e22e>remove</span>(msgId);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (parentId <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                mergeMsgMap.<span style=color:#a6e22e>remove</span>(parentId);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (future <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                LOGGER.<span style=color:#a6e22e>error</span>(
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#34;msg: {} is not found in futures, result message: {}&#34;</span>,
</span></span><span style=display:flex><span>                        msgId,
</span></span><span style=display:flex><span>                        batchResultMessage.<span style=color:#a6e22e>getResultMessages</span>().<span style=color:#a6e22e>get</span>(i));
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                future.<span style=color:#a6e22e>setResultMessage</span>(
</span></span><span style=display:flex><span>                        batchResultMessage.<span style=color:#a6e22e>getResultMessages</span>().<span style=color:#a6e22e>get</span>(i));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 非批量响应报文处理</span>
</span></span><span style=display:flex><span>        Integer id <span style=color:#f92672>=</span> rpcMessage.<span style=color:#a6e22e>getId</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            MessageFuture messageFuture <span style=color:#f92672>=</span> futures.<span style=color:#a6e22e>remove</span>(id);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (messageFuture <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                messageFuture.<span style=color:#a6e22e>setResultMessage</span>(rpcMessage.<span style=color:#a6e22e>getBody</span>());
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (rpcMessage.<span style=color:#a6e22e>getBody</span>() <span style=color:#66d9ef>instanceof</span> AbstractResultMessage) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (transactionMessageHandler <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                        transactionMessageHandler.<span style=color:#a6e22e>onResponse</span>((AbstractResultMessage) rpcMessage.<span style=color:#a6e22e>getBody</span>(), <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// In version 2.3.0, the server does not return MergeResultMessage and BatchResultMessage</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// so it is necessary to clear childToParentMap and mergeMsgMap here.</span>
</span></span><span style=display:flex><span>            Integer parentId <span style=color:#f92672>=</span> childToParentMap.<span style=color:#a6e22e>remove</span>(id);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (parentId <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                mergeMsgMap.<span style=color:#a6e22e>remove</span>(parentId);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当然，这里处理的逻辑很简单，就是将结果塞到对应的 MessageFuture 中，那么最开始发送请求的、阻塞的线程就可以拿到结果了，这样一次批量发送和响应就算处理完毕了。</p><p>最后，我们再做一些额外的思考，Seata 的批量发送为什么有两种方式，孰优孰劣？</p><p>对于 MergeResultMessage 的这种方式来说，它必须等到所有的报文都处理完毕之后才会发送出去，所以其实它的响应速度受限于处理最长时间的报文，即使其他报文在很短时间内就可以发送出去。</p><p>而 BatchResultMessage 这种方式则不然，配置 CompletableFuture 进行并行处理，它就可以实现一有报文处理完毕就发送，而不需要等其他报文的处理，它的响应速度肯定是更快的。</p><p>而后面这种方式是 Seata 1.5 版本之后才有的，其实也可以看出来这是一种更好地处理方式。</p><h2 id=如何管理-channel>如何管理 Channel</h2><p>在整个 TC、TM、RM 的网络通信的过程中，Channel 是一个至关重要的通信组件，而要想知道 Seata 是怎么管理 Channel 的，最容易想到的入口就是看 Server 和 Client 发送报文时是从哪里拿到到 Channel 的。</p><p>在 AbstractNettyRemotingClient 类的 sendSyncRequest 中，我们可以看到下面的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>sendSyncRequest</span>(Object msg) <span style=color:#66d9ef>throws</span> TimeoutException {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Client 通过 NettyClientChannelManager 获取 Channel</span>
</span></span><span style=display:flex><span>    Channel channel <span style=color:#f92672>=</span> clientChannelManager.<span style=color:#a6e22e>acquireChannel</span>(serverAddress);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>sendSync</span>(channel, rpcMessage, timeoutMillis);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>而在 AbstractNettyRemotingServer 类的 sendSyncRequest 中，我们可以看到下面的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>sendSyncRequest</span>(String resourceId, String clientId, Object msg, <span style=color:#66d9ef>boolean</span> tryOtherApp) <span style=color:#66d9ef>throws</span> TimeoutException {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Server 通过 ChannelManager 拿到 Channel</span>
</span></span><span style=display:flex><span>    Channel channel <span style=color:#f92672>=</span> ChannelManager.<span style=color:#a6e22e>getChannel</span>(resourceId, clientId, tryOtherApp);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (channel <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(<span style=color:#e6db74>&#34;rm client is not connected. dbkey:&#34;</span> <span style=color:#f92672>+</span> resourceId <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;,clientId:&#34;</span> <span style=color:#f92672>+</span> clientId);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    RpcMessage rpcMessage <span style=color:#f92672>=</span> buildRequestMessage(msg, ProtocolConstants.<span style=color:#a6e22e>MSGTYPE_RESQUEST_SYNC</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>sendSync</span>(channel, rpcMessage, NettyServerConfig.<span style=color:#a6e22e>getRpcRequestTimeout</span>());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>所以在客户端主要是通过 NettyClientChannelManager 中获取 Channel，而服务端则是根据 resourceId 和 clientId 从 ChannelManager 中获取 Channel。</p><p>所以下面我们主要研究的就是这两个类，以及相关的一些逻辑。</p><h3 id=client-channel>Client Channel</h3><p>我们先来看 Client 这边是怎么管理 Channel 的，核心类是 NettyClientChannelManager。</p><p>先简单看一下这个类的属性，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// serverAddress -&gt; lock</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> ConcurrentMap<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span> channelLocks <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConcurrentHashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>// serverAddress -&gt; NettyPoolKey</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> ConcurrentMap<span style=color:#f92672>&lt;</span>String, NettyPoolKey<span style=color:#f92672>&gt;</span> poolKeyMap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConcurrentHashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>// serverAddress -&gt; Channel</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> ConcurrentMap<span style=color:#f92672>&lt;</span>String, Channel<span style=color:#f92672>&gt;</span> channels <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConcurrentHashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>// 对象池，NettyPoolKey -&gt; Channel</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> GenericKeyedObjectPool<span style=color:#f92672>&lt;</span>NettyPoolKey, Channel<span style=color:#f92672>&gt;</span> nettyClientKeyPool;
</span></span><span style=display:flex><span><span style=color:#75715e>// 函数式接口，封装了通过 serverAddress 获取 NettyPoolKey 的逻辑</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Function<span style=color:#f92672>&lt;</span>String, NettyPoolKey<span style=color:#f92672>&gt;</span> poolKeyFunction;
</span></span></code></pre></div><h4 id=对象池的核心类>对象池的核心类</h4><p>Seata 使用了 GenericKeyedObjectPool 作为管理 Channel 的对象池。</p><p>GenericKeyedObjectPool 作为 Apache Commons Pool 库中的一个实现，它主要用于管理一组对象池，每个对象通过唯一的 Key 进行区分，可以支持多类型的对象池化需求。</p><p>在使用 GenericKeyedObjectPool 时，通常还需要配置 KeyedPoolableObjectFactory 工厂，这个工厂定义了如何创建、验证、激活、钝化以及销毁池中的对象。</p><p>当 GenericKeyedObjectPool 需要创建对象时会调用 KeyedPoolableObjectFactory 工厂的 makeObject 方法，当需要销毁时会调用 destroyObject 方法进行销毁 ……</p><h4 id=如何池化-channel>如何池化 Channel</h4><p>被池化的对象就是 Channel，而对应的 Key 是 NettyPoolKey，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NettyPoolKey</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> TransactionRole transactionRole;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String address;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> AbstractMessage message;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 NettyPoolKey 中，维护了三个信息，事务角色（TMROLE、RMROLE、SERVERROLE），目的 TC Server 地址，以及在 Client 连接 Server 时发送的 RPC 报文。</p><p>如何创建这个 NettyPoolKey 呢？在 Seata 中，客户端其实是有两种角色的，TM 和 RM，创建的逻辑肯定是不一样的，所以，Seata 在 AbstractNettyRemotingClient 中抽象了一个方法，它的返回值是一个函数式接口，这个函数式接口就封装了根据 serverAddress 创建 NettyPoolKey 的逻辑。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.apache.seata.core.rpc.netty.AbstractNettyRemotingClient#getPoolKeyFunction</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>abstract</span> Function<span style=color:#f92672>&lt;</span>String, NettyPoolKey<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>getPoolKeyFunction</span>();
</span></span></code></pre></div><p>比如在 TM 中的实现是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>protected</span> Function<span style=color:#f92672>&lt;</span>String, NettyPoolKey<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>getPoolKeyFunction</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> severAddress <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>        RegisterTMRequest message <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> RegisterTMRequest(applicationId, transactionServiceGroup, getExtraData());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> NettyPoolKey(NettyPoolKey.<span style=color:#a6e22e>TransactionRole</span>.<span style=color:#a6e22e>TM_ROLE</span>, severAddress, message);
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>而在 RM 中的实现是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>protected</span> Function<span style=color:#f92672>&lt;</span>String, NettyPoolKey<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>getPoolKeyFunction</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> serverAddress <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>        String resourceIds <span style=color:#f92672>=</span> getMergedResourceKeys();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (resourceIds <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> LOGGER.<span style=color:#a6e22e>isInfoEnabled</span>()) {
</span></span><span style=display:flex><span>            LOGGER.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;RM will register: {}&#34;</span>, resourceIds);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        RegisterRMRequest message <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> RegisterRMRequest(applicationId, transactionServiceGroup);
</span></span><span style=display:flex><span>        message.<span style=color:#a6e22e>setResourceIds</span>(resourceIds);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> NettyPoolKey(NettyPoolKey.<span style=color:#a6e22e>TransactionRole</span>.<span style=color:#a6e22e>RM_ROLE</span>, serverAddress, message);
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>从这里就可以看到，TM 在连接 Server 后发送的报文是 RegisterTMRequest，而 RM 是 RegisterRMRequest。</p><p>那这个函数式接口在什么时候被调用呢，后面再看。</p><p>我们前面也说到了，一个对象池，会配备对应的对象创建工厂 KeyedPoolableObjectFactory，在 Seata 中，以 NettyPoolableFactory 继承 KeyedPoolableObjectFactory 来实现。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Netty Channel 创建工厂，通过 NettyPoolKey 创建 Channel，该类的方法必须是线程安全的
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NettyPoolableFactory</span> <span style=color:#66d9ef>implements</span> KeyedPoolableObjectFactory<span style=color:#f92672>&lt;</span>NettyPoolKey, Channel<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 需要一个新的实例则调用该方法
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Channel <span style=color:#a6e22e>makeObject</span>(NettyPoolKey key) {
</span></span><span style=display:flex><span>        InetSocketAddress address <span style=color:#f92672>=</span> NetUtil.<span style=color:#a6e22e>toInetSocketAddress</span>(key.<span style=color:#a6e22e>getAddress</span>());
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建 Channel，本质上就是通过 bootstrap.connect 连接到 Seata Server 返回 Channel</span>
</span></span><span style=display:flex><span>        Channel tmpChannel <span style=color:#f92672>=</span> clientBootstrap.<span style=color:#a6e22e>getNewChannel</span>(address);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> start <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>();
</span></span><span style=display:flex><span>        Object response;
</span></span><span style=display:flex><span>        Channel channelToServer <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (key.<span style=color:#a6e22e>getMessage</span>() <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> FrameworkException(<span style=color:#e6db74>&#34;register msg is null, role:&#34;</span> <span style=color:#f92672>+</span> key.<span style=color:#a6e22e>getTransactionRole</span>().<span style=color:#a6e22e>name</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 发送同步请求，TM 就是 RegisterTMRequest，RM 就是 RegisterRMRequest</span>
</span></span><span style=display:flex><span>            response <span style=color:#f92672>=</span> rpcRemotingClient.<span style=color:#a6e22e>sendSyncRequest</span>(tmpChannel, key.<span style=color:#a6e22e>getMessage</span>());
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 根据 response 判断是否注册成功</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isRegisterSuccess(response, key.<span style=color:#a6e22e>getTransactionRole</span>())) {
</span></span><span style=display:flex><span>                rpcRemotingClient.<span style=color:#a6e22e>onRegisterMsgFail</span>(key.<span style=color:#a6e22e>getAddress</span>(), tmpChannel, response, key.<span style=color:#a6e22e>getMessage</span>());
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 注册成功</span>
</span></span><span style=display:flex><span>                channelToServer <span style=color:#f92672>=</span> tmpChannel;
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 将 serverAddress 作为 key，Channel 作为 value，添加到 NettyClientChannelManager.channels 中</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 如果是 RM 可能还需要向 Server 注册 resources</span>
</span></span><span style=display:flex><span>                rpcRemotingClient.<span style=color:#a6e22e>onRegisterMsgSuccess</span>(key.<span style=color:#a6e22e>getAddress</span>(), tmpChannel, response, key.<span style=color:#a6e22e>getMessage</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception exx) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (tmpChannel <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                tmpChannel.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> FrameworkException(<span style=color:#e6db74>&#34;register &#34;</span> <span style=color:#f92672>+</span> key.<span style=color:#a6e22e>getTransactionRole</span>().<span style=color:#a6e22e>name</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; error, errMsg:&#34;</span> <span style=color:#f92672>+</span> exx.<span style=color:#a6e22e>getMessage</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> channelToServer;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>destroyObject</span>(NettyPoolKey key, Channel channel) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (channel <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            channel.<span style=color:#a6e22e>disconnect</span>();
</span></span><span style=display:flex><span>            channel.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 需要借用对象时会调用该方法校验对象有效性（可选）
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>validateObject</span>(NettyPoolKey key, Channel obj) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (obj <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> obj.<span style=color:#a6e22e>isActive</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 需要借用对象时会调用该方法激活对象
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>activateObject</span>(NettyPoolKey key, Channel obj) <span style=color:#66d9ef>throws</span> Exception {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 归还对象时会调用该方法钝化对象
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>passivateObject</span>(NettyPoolKey key, Channel obj) <span style=color:#66d9ef>throws</span> Exception {}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=获取-channel>获取 Channel</h4><p>在整个 Seata 客户端，有三个口径可以获取 Channel，即初始化、定时重连，发送报文时获取 Channel。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 口径一</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initConnection</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> failFast <span style=color:#f92672>=</span> ConfigurationFactory.<span style=color:#a6e22e>getInstance</span>()
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>getBoolean</span>(
</span></span><span style=display:flex><span>                    ConfigurationKeys.<span style=color:#a6e22e>ENABLE_TM_CLIENT_CHANNEL_CHECK_FAIL_FAST</span>,
</span></span><span style=display:flex><span>                    DefaultValues.<span style=color:#a6e22e>DEFAULT_CLIENT_CHANNEL_CHECK_FAIL_FAST</span>);
</span></span><span style=display:flex><span>    getClientChannelManager().<span style=color:#a6e22e>initReconnect</span>(transactionServiceGroup, failFast);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 口径二</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 默认延时 60s 定时 10s 周期重连</span>
</span></span><span style=display:flex><span>    timerExecutor.<span style=color:#a6e22e>scheduleAtFixedRate</span>(
</span></span><span style=display:flex><span>            () <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    clientChannelManager.<span style=color:#a6e22e>reconnect</span>(getTransactionServiceGroup());
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (Exception ex) {
</span></span><span style=display:flex><span>                    LOGGER.<span style=color:#a6e22e>warn</span>(<span style=color:#e6db74>&#34;reconnect server failed. {}&#34;</span>, ex.<span style=color:#a6e22e>getMessage</span>());
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            SCHEDULE_DELAY_MILLS,
</span></span><span style=display:flex><span>            SCHEDULE_INTERVAL_MILLS,
</span></span><span style=display:flex><span>            TimeUnit.<span style=color:#a6e22e>MILLISECONDS</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 口径三</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>sendSyncRequest</span>(Object msg) <span style=color:#66d9ef>throws</span> TimeoutException {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Client 通过 NettyClientChannelManager 获取 Channel</span>
</span></span><span style=display:flex><span>    Channel channel <span style=color:#f92672>=</span> clientChannelManager.<span style=color:#a6e22e>acquireChannel</span>(serverAddress);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>sendSync</span>(channel, rpcMessage, timeoutMillis);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>不过，这三个口径最后都会调用到 clientChannelManager 的 acquireChannel 方法获取 Channel。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 根据 serverAddress 拿到 Channel，如果 Channel 不存在或者连接已死则需要重新建立连接
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>Channel <span style=color:#a6e22e>acquireChannel</span>(String serverAddress) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 从 channels 中根据 serverAddress 拿到 Channel</span>
</span></span><span style=display:flex><span>    Channel channelToServer <span style=color:#f92672>=</span> channels.<span style=color:#a6e22e>get</span>(serverAddress);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (channelToServer <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        channelToServer <span style=color:#f92672>=</span> getExistAliveChannel(channelToServer, serverAddress);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (channelToServer <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> channelToServer;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果 channels 没有这个 Channel 或者这个 Channel 已断开，则需要对这个地址建立连接</span>
</span></span><span style=display:flex><span>    Object lockObj <span style=color:#f92672>=</span> CollectionUtils.<span style=color:#a6e22e>computeIfAbsent</span>(channelLocks, serverAddress, key <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>new</span> Object());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span> (lockObj) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 建立连接</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> doConnect(serverAddress);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> Channel <span style=color:#a6e22e>doConnect</span>(String serverAddress) {
</span></span><span style=display:flex><span>    Channel channelToServer <span style=color:#f92672>=</span> channels.<span style=color:#a6e22e>get</span>(serverAddress);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (channelToServer <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> channelToServer.<span style=color:#a6e22e>isActive</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> channelToServer;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Channel channelFromPool;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 这里就调用了函数式接口</span>
</span></span><span style=display:flex><span>        NettyPoolKey currentPoolKey <span style=color:#f92672>=</span> poolKeyFunction.<span style=color:#a6e22e>apply</span>(serverAddress);
</span></span><span style=display:flex><span>        poolKeyMap.<span style=color:#a6e22e>put</span>(serverAddress, currentPoolKey);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 从对象池中 borrowObject，如果需要创建对象，则会调用工厂的 makeObject 方法，</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 该方法内部就会向 Server 进行 connect，并且发送 currentPoolKey.message 的报文</span>
</span></span><span style=display:flex><span>        channelFromPool <span style=color:#f92672>=</span> nettyClientKeyPool.<span style=color:#a6e22e>borrowObject</span>(currentPoolKey);
</span></span><span style=display:flex><span>        channels.<span style=color:#a6e22e>put</span>(serverAddress, channelFromPool);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Exception exx) {
</span></span><span style=display:flex><span>        LOGGER.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;{} register RM failed.&#34;</span>, FrameworkErrorCode.<span style=color:#a6e22e>RegisterRM</span>.<span style=color:#a6e22e>getErrCode</span>(), exx);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> FrameworkException(<span style=color:#e6db74>&#34;can not register RM,err:&#34;</span> <span style=color:#f92672>+</span> exx.<span style=color:#a6e22e>getMessage</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> channelFromPool;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=server-channel>Server Channel</h3><p>而在 Server 这边，基本上有关 Channe 管理的核心逻辑都在 ChannelManager 中，那 Server 这边的 Channel 是怎么来的呢？还记得在 Client 那边向 Server 初次连接时，连接成功之后还会发送 TM 和 RM 的一个注册请求。</p><p>这里先来看看 Server 是怎么处理这些 registerRequest 的。</p><h4 id=处理-client-注册>处理 Client 注册</h4><p>与之相关的处理器是 RegRmProcessor 和 RegTmProcessor，在这两个处理器中，最核心的逻辑就是调用 ChannelManager 的 registerTMChannel 和 registerRMChannel 方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>registerTMChannel</span>(RegisterTMRequest request, Channel channel)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throws</span> IncompatibleVersionException {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 构建 RpcContext，这个 RpcContext 就是维护了客户端连接信息上下文</span>
</span></span><span style=display:flex><span>    RpcContext rpcContext <span style=color:#f92672>=</span> buildChannelHolder(
</span></span><span style=display:flex><span>            NettyPoolKey.<span style=color:#a6e22e>TransactionRole</span>.<span style=color:#a6e22e>TMROLE</span>,
</span></span><span style=display:flex><span>            request.<span style=color:#a6e22e>getVersion</span>(),
</span></span><span style=display:flex><span>            request.<span style=color:#a6e22e>getApplicationId</span>(),
</span></span><span style=display:flex><span>            request.<span style=color:#a6e22e>getTransactionServiceGroup</span>(),
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>            channel);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将 Channel 作为 key，rpcContext 作为 value，put 到 IDENTIFIED_CHANNELS 中</span>
</span></span><span style=display:flex><span>    rpcContext.<span style=color:#a6e22e>holdInIdentifiedChannels</span>(IDENTIFIED_CHANNELS);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// applicationId:clientIp</span>
</span></span><span style=display:flex><span>    String clientIdentified <span style=color:#f92672>=</span> rpcContext.<span style=color:#a6e22e>getApplicationId</span>()
</span></span><span style=display:flex><span>            <span style=color:#f92672>+</span> Constants.<span style=color:#a6e22e>CLIENT_ID_SPLIT_CHAR</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>+</span> ChannelUtil.<span style=color:#a6e22e>getClientIpFromChannel</span>(channel);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将 Channel 信息存储到 TM_CHANNELS 中</span>
</span></span><span style=display:flex><span>    ConcurrentMap<span style=color:#f92672>&lt;</span>Integer, RpcContext<span style=color:#f92672>&gt;</span> clientIdentifiedMap <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>            CollectionUtils.<span style=color:#a6e22e>computeIfAbsent</span>(TM_CHANNELS, clientIdentified, key <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>new</span> ConcurrentHashMap<span style=color:#f92672>&lt;&gt;</span>());
</span></span><span style=display:flex><span>    rpcContext.<span style=color:#a6e22e>holdInClientChannels</span>(clientIdentifiedMap);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>registerRMChannel</span>(RegisterRMRequest resourceManagerRequest, Channel channel)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throws</span> IncompatibleVersionException {
</span></span><span style=display:flex><span>    Set<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> dbkeySet <span style=color:#f92672>=</span> dbKeytoSet(resourceManagerRequest.<span style=color:#a6e22e>getResourceIds</span>());
</span></span><span style=display:flex><span>    RpcContext rpcContext;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>IDENTIFIED_CHANNELS.<span style=color:#a6e22e>containsKey</span>(channel)) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 构建 RpcContext 和 IDENTIFIED_CHANNELS</span>
</span></span><span style=display:flex><span>        rpcContext <span style=color:#f92672>=</span> buildChannelHolder(
</span></span><span style=display:flex><span>                NettyPoolKey.<span style=color:#a6e22e>TransactionRole</span>.<span style=color:#a6e22e>RMROLE</span>,
</span></span><span style=display:flex><span>                resourceManagerRequest.<span style=color:#a6e22e>getVersion</span>(),
</span></span><span style=display:flex><span>                resourceManagerRequest.<span style=color:#a6e22e>getApplicationId</span>(),
</span></span><span style=display:flex><span>                resourceManagerRequest.<span style=color:#a6e22e>getTransactionServiceGroup</span>(),
</span></span><span style=display:flex><span>                resourceManagerRequest.<span style=color:#a6e22e>getResourceIds</span>(),
</span></span><span style=display:flex><span>                channel);
</span></span><span style=display:flex><span>        rpcContext.<span style=color:#a6e22e>holdInIdentifiedChannels</span>(IDENTIFIED_CHANNELS);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        rpcContext <span style=color:#f92672>=</span> IDENTIFIED_CHANNELS.<span style=color:#a6e22e>get</span>(channel);
</span></span><span style=display:flex><span>        rpcContext.<span style=color:#a6e22e>addResources</span>(dbkeySet);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (dbkeySet <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> dbkeySet.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (String resourceId : dbkeySet) {
</span></span><span style=display:flex><span>        String clientIp;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 维护 RM_CHANNELS 信息</span>
</span></span><span style=display:flex><span>        ConcurrentMap<span style=color:#f92672>&lt;</span>Integer, RpcContext<span style=color:#f92672>&gt;</span> portMap <span style=color:#f92672>=</span> CollectionUtils.<span style=color:#a6e22e>computeIfAbsent</span>(
</span></span><span style=display:flex><span>                        RM_CHANNELS, resourceId, key <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>new</span> ConcurrentHashMap<span style=color:#f92672>&lt;&gt;</span>())
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>computeIfAbsent</span>(resourceManagerRequest.<span style=color:#a6e22e>getApplicationId</span>(), key <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>new</span> ConcurrentHashMap<span style=color:#f92672>&lt;&gt;</span>())
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>computeIfAbsent</span>(
</span></span><span style=display:flex><span>                        clientIp <span style=color:#f92672>=</span> ChannelUtil.<span style=color:#a6e22e>getClientIpFromChannel</span>(channel), key <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>new</span> ConcurrentHashMap<span style=color:#f92672>&lt;&gt;</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        rpcContext.<span style=color:#a6e22e>holdInResourceManagerChannels</span>(resourceId, portMap);
</span></span><span style=display:flex><span>        updateChannelsResource(resourceId, clientIp, resourceManagerRequest.<span style=color:#a6e22e>getApplicationId</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这两个方法逻辑很简单，就是基于注册请求和 Channel 的信息构建 RpcContext，维护 Server 内的相关 Map 集合，IDENTIFIED_CHANNELS、RM_CHANNELS、TM_CHANNELS。</p><p>但是，说实话，这几个集合实在是嵌套的有点深，不知道能不能优化一下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Channel -&gt; RpcContext
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> ConcurrentMap<span style=color:#f92672>&lt;</span>Channel, RpcContext<span style=color:#f92672>&gt;</span> IDENTIFIED_CHANNELS <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConcurrentHashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * resourceId -&gt; applicationId -&gt; ip -&gt; port -&gt; RpcContext
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//                               resourceId          applicationId               ip</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> ConcurrentMap<span style=color:#f92672>&lt;</span>String, ConcurrentMap<span style=color:#f92672>&lt;</span>String, ConcurrentMap<span style=color:#f92672>&lt;</span>String,
</span></span><span style=display:flex><span>        <span style=color:#75715e>//             port    RpcContext</span>
</span></span><span style=display:flex><span>        ConcurrentMap<span style=color:#f92672>&lt;</span>Integer, RpcContext<span style=color:#f92672>&gt;&gt;&gt;&gt;</span> RM_CHANNELS <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConcurrentHashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * applicationId:clientIp -&gt; port -&gt; RpcContext
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> ConcurrentMap<span style=color:#f92672>&lt;</span>String, ConcurrentMap<span style=color:#f92672>&lt;</span>Integer, RpcContext<span style=color:#f92672>&gt;&gt;</span> TM_CHANNELS <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConcurrentHashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span></code></pre></div><h4 id=获取-channel-1>获取 Channel</h4><p>在 Server 这边，获取 Channel 的逻辑，真的是超长，感兴趣自己看看吧，本质上就是从 map 中拿到一个有效的 Channel。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Channel <span style=color:#a6e22e>getChannel</span>(String resourceId, String clientId, <span style=color:#66d9ef>boolean</span> tryOtherApp) {
</span></span><span style=display:flex><span>    Channel resultChannel <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 解析 ClientId，三部分组成：applicationId + clientIp + clientPort</span>
</span></span><span style=display:flex><span>    String<span style=color:#f92672>[]</span> clientIdInfo <span style=color:#f92672>=</span> parseClientId(clientId);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (clientIdInfo <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> clientIdInfo.<span style=color:#a6e22e>length</span> <span style=color:#f92672>!=</span> 3) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> FrameworkException(<span style=color:#e6db74>&#34;Invalid Client ID: &#34;</span> <span style=color:#f92672>+</span> clientId);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (StringUtils.<span style=color:#a6e22e>isBlank</span>(resourceId)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (LOGGER.<span style=color:#a6e22e>isInfoEnabled</span>()) {
</span></span><span style=display:flex><span>            LOGGER.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;No channel is available, resourceId is null or empty&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// applicationId</span>
</span></span><span style=display:flex><span>    String targetApplicationId <span style=color:#f92672>=</span> clientIdInfo<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// clientIp</span>
</span></span><span style=display:flex><span>    String targetIP <span style=color:#f92672>=</span> clientIdInfo<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// clientPort</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> targetPort <span style=color:#f92672>=</span> Integer.<span style=color:#a6e22e>parseInt</span>(clientIdInfo<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 下面就是不断取出内层的 ConcurrentHashMap</span>
</span></span><span style=display:flex><span>    ConcurrentMap<span style=color:#f92672>&lt;</span>String, ConcurrentMap<span style=color:#f92672>&lt;</span>String, ConcurrentMap<span style=color:#f92672>&lt;</span>Integer, RpcContext<span style=color:#f92672>&gt;&gt;&gt;</span> applicationIdMap <span style=color:#f92672>=</span> RM_CHANNELS.<span style=color:#a6e22e>get</span>(resourceId);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (targetApplicationId <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> applicationIdMap <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> applicationIdMap.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (LOGGER.<span style=color:#a6e22e>isInfoEnabled</span>()) {
</span></span><span style=display:flex><span>            LOGGER.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;No channel is available for resource[{}]&#34;</span>, resourceId);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ConcurrentMap<span style=color:#f92672>&lt;</span>String, ConcurrentMap<span style=color:#f92672>&lt;</span>Integer, RpcContext<span style=color:#f92672>&gt;&gt;</span> ipMap <span style=color:#f92672>=</span> applicationIdMap.<span style=color:#a6e22e>get</span>(targetApplicationId);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (ipMap <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>ipMap.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Firstly, try to find the original channel through which the branch was registered.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 端口 -&gt; RpcContext</span>
</span></span><span style=display:flex><span>        ConcurrentMap<span style=color:#f92672>&lt;</span>Integer, RpcContext<span style=color:#f92672>&gt;</span> portMapOnTargetIP <span style=color:#f92672>=</span> ipMap.<span style=color:#a6e22e>get</span>(targetIP);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 在 targetIp 上拿 Channel
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (portMapOnTargetIP <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>portMapOnTargetIP.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>            RpcContext exactRpcContext <span style=color:#f92672>=</span> portMapOnTargetIP.<span style=color:#a6e22e>get</span>(targetPort);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (exactRpcContext <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                Channel channel <span style=color:#f92672>=</span> exactRpcContext.<span style=color:#a6e22e>getChannel</span>();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (channel.<span style=color:#a6e22e>isActive</span>()) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Channel 有效，则跳过下面所有的 if 返回这个 Channel</span>
</span></span><span style=display:flex><span>                    resultChannel <span style=color:#f92672>=</span> channel;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (LOGGER.<span style=color:#a6e22e>isDebugEnabled</span>()) {
</span></span><span style=display:flex><span>                        LOGGER.<span style=color:#a6e22e>debug</span>(<span style=color:#e6db74>&#34;Just got exactly the one {} for {}&#34;</span>, channel, clientId);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (portMapOnTargetIP.<span style=color:#a6e22e>remove</span>(targetPort, exactRpcContext)) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (LOGGER.<span style=color:#a6e22e>isInfoEnabled</span>()) {
</span></span><span style=display:flex><span>                            LOGGER.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Removed inactive {}&#34;</span>, channel);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// The original channel was broken, try another one.</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (resultChannel <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 尝试当前节点上的其他端口</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (ConcurrentMap.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>Integer, RpcContext<span style=color:#f92672>&gt;</span> portMapOnTargetIPEntry : portMapOnTargetIP.<span style=color:#a6e22e>entrySet</span>()) {
</span></span><span style=display:flex><span>                    Channel channel <span style=color:#f92672>=</span> portMapOnTargetIPEntry.<span style=color:#a6e22e>getValue</span>().<span style=color:#a6e22e>getChannel</span>();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (channel.<span style=color:#a6e22e>isActive</span>()) {
</span></span><span style=display:flex><span>                        resultChannel <span style=color:#f92672>=</span> channel;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (LOGGER.<span style=color:#a6e22e>isInfoEnabled</span>()) {
</span></span><span style=display:flex><span>                            LOGGER.<span style=color:#a6e22e>info</span>(
</span></span><span style=display:flex><span>                                    <span style=color:#e6db74>&#34;Choose {} on the same IP[{}] as alternative of {}&#34;</span>, channel, targetIP, clientId);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (portMapOnTargetIP.<span style=color:#a6e22e>remove</span>(portMapOnTargetIPEntry.<span style=color:#a6e22e>getKey</span>(),
</span></span><span style=display:flex><span>                                portMapOnTargetIPEntry.<span style=color:#a6e22e>getValue</span>())) {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> (LOGGER.<span style=color:#a6e22e>isInfoEnabled</span>()) {
</span></span><span style=display:flex><span>                                LOGGER.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Removed inactive {}&#34;</span>, channel);
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 在 targetApplicationId 上拿 Channel
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// No channel on the app node, try another one.</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (resultChannel <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (ConcurrentMap.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>String, ConcurrentMap<span style=color:#f92672>&lt;</span>Integer, RpcContext<span style=color:#f92672>&gt;&gt;</span> ipMapEntry : ipMap.<span style=color:#a6e22e>entrySet</span>()) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (ipMapEntry.<span style=color:#a6e22e>getKey</span>().<span style=color:#a6e22e>equals</span>(targetIP)) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                ConcurrentMap<span style=color:#f92672>&lt;</span>Integer, RpcContext<span style=color:#f92672>&gt;</span> portMapOnOtherIP <span style=color:#f92672>=</span> ipMapEntry.<span style=color:#a6e22e>getValue</span>();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (portMapOnOtherIP <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> portMapOnOtherIP.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (ConcurrentMap.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>Integer, RpcContext<span style=color:#f92672>&gt;</span> portMapOnOtherIPEntry : portMapOnOtherIP.<span style=color:#a6e22e>entrySet</span>()) {
</span></span><span style=display:flex><span>                    Channel channel <span style=color:#f92672>=</span> portMapOnOtherIPEntry.<span style=color:#a6e22e>getValue</span>().<span style=color:#a6e22e>getChannel</span>();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (channel.<span style=color:#a6e22e>isActive</span>()) {
</span></span><span style=display:flex><span>                        resultChannel <span style=color:#f92672>=</span> channel;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (LOGGER.<span style=color:#a6e22e>isInfoEnabled</span>()) {
</span></span><span style=display:flex><span>                            LOGGER.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Choose {} on the same application[{}] as alternative of {}&#34;</span>, channel, targetApplicationId, clientId);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (portMapOnOtherIP.<span style=color:#a6e22e>remove</span>(portMapOnOtherIPEntry.<span style=color:#a6e22e>getKey</span>(), portMapOnOtherIPEntry.<span style=color:#a6e22e>getValue</span>())) {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> (LOGGER.<span style=color:#a6e22e>isInfoEnabled</span>()) {
</span></span><span style=display:flex><span>                                LOGGER.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Removed inactive {}&#34;</span>, channel);
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (resultChannel <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (resultChannel <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> tryOtherApp) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 尝试其他 applicationId</span>
</span></span><span style=display:flex><span>        resultChannel <span style=color:#f92672>=</span> tryOtherApp(applicationIdMap, targetApplicationId);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (resultChannel <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (LOGGER.<span style=color:#a6e22e>isInfoEnabled</span>()) {
</span></span><span style=display:flex><span>                LOGGER.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;No channel is available for resource[{}] as alternative of {}&#34;</span>, resourceId, clientId);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (LOGGER.<span style=color:#a6e22e>isInfoEnabled</span>()) {
</span></span><span style=display:flex><span>                LOGGER.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Choose {} on the same resource[{}] as alternative of {}&#34;</span>, resultChannel, resourceId, clientId);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> resultChannel;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Channel <span style=color:#a6e22e>tryOtherApp</span>(ConcurrentMap<span style=color:#f92672>&lt;</span>String, ConcurrentMap<span style=color:#f92672>&lt;</span>String, ConcurrentMap<span style=color:#f92672>&lt;</span>Integer, RpcContext<span style=color:#f92672>&gt;&gt;&gt;</span> applicationIdMap, String myApplicationId) {
</span></span><span style=display:flex><span>    Channel chosenChannel <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (ConcurrentMap.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>String, ConcurrentMap<span style=color:#f92672>&lt;</span>String, ConcurrentMap<span style=color:#f92672>&lt;</span>Integer, RpcContext<span style=color:#f92672>&gt;&gt;&gt;</span> applicationIdMapEntry : applicationIdMap.<span style=color:#a6e22e>entrySet</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>StringUtils.<span style=color:#a6e22e>isNullOrEmpty</span>(myApplicationId) <span style=color:#f92672>&amp;&amp;</span> applicationIdMapEntry.<span style=color:#a6e22e>getKey</span>().<span style=color:#a6e22e>equals</span>(myApplicationId)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        ConcurrentMap<span style=color:#f92672>&lt;</span>String, ConcurrentMap<span style=color:#f92672>&lt;</span>Integer, RpcContext<span style=color:#f92672>&gt;&gt;</span> targetIPMap <span style=color:#f92672>=</span> applicationIdMapEntry.<span style=color:#a6e22e>getValue</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (targetIPMap <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> targetIPMap.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (ConcurrentMap.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>String, ConcurrentMap<span style=color:#f92672>&lt;</span>Integer, RpcContext<span style=color:#f92672>&gt;&gt;</span> targetIPMapEntry : targetIPMap.<span style=color:#a6e22e>entrySet</span>()) {
</span></span><span style=display:flex><span>            ConcurrentMap<span style=color:#f92672>&lt;</span>Integer, RpcContext<span style=color:#f92672>&gt;</span> portMap <span style=color:#f92672>=</span> targetIPMapEntry.<span style=color:#a6e22e>getValue</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (portMap <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> portMap.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (ConcurrentMap.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>Integer, RpcContext<span style=color:#f92672>&gt;</span> portMapEntry : portMap.<span style=color:#a6e22e>entrySet</span>()) {
</span></span><span style=display:flex><span>                Channel channel <span style=color:#f92672>=</span> portMapEntry.<span style=color:#a6e22e>getValue</span>().<span style=color:#a6e22e>getChannel</span>();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (channel.<span style=color:#a6e22e>isActive</span>()) {
</span></span><span style=display:flex><span>                    chosenChannel <span style=color:#f92672>=</span> channel;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (portMap.<span style=color:#a6e22e>remove</span>(portMapEntry.<span style=color:#a6e22e>getKey</span>(), portMapEntry.<span style=color:#a6e22e>getValue</span>())) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (LOGGER.<span style=color:#a6e22e>isInfoEnabled</span>()) {
</span></span><span style=display:flex><span>                            LOGGER.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Removed inactive {}&#34;</span>, channel);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (chosenChannel <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (chosenChannel <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> chosenChannel;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=一图总结>一图总结</h3><p>最后，再以一个时序图来总结一下 Channel 的管理过程。</p><p><img src=assets/6be183fd54d3708b4f146f9cc8b2c1e3.svg alt class=rounded-shadow-image loading=lazy></p><h2 id=如何设计协议>如何设计协议</h2><p>对于一个网络程序而言，通信协议是必不可少的，Seata 也不例外，这里我们就看看 Seata V1 版本的协议是如何实现的。</p><p>与之相关类主要有 ProtocolEncoderV1、ProtocolDecoderV1。</p><p>在回顾一下前面在 Server 端启动时向 Netty 加入的处理器有哪些？IdleStateHandler 和 ProtocolDetectHandler。</p><p>首先 IdleStateHandler 是 Netty 内置的一个 ChannelHandler，主要用于检测连接的空闲状态，它可以监控读空闲、写空闲和读写空闲，当检测到空闲时，就会触发 IdleStateEvent 事件，需要通过 userEventTriggered 处理。</p><p>这里的重点自然是 ProtocolDetectHandler，它是一个 ByteToMessageDecoder，decode 方法如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>decode</span>(ChannelHandlerContext ctx, ByteBuf in, List<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> out) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (ProtocolDetector protocolDetector : supportedProtocolDetectors) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (protocolDetector.<span style=color:#a6e22e>detect</span>(in)) {
</span></span><span style=display:flex><span>            ChannelHandler<span style=color:#f92672>[]</span> protocolHandlers <span style=color:#f92672>=</span> protocolDetector.<span style=color:#a6e22e>getHandlers</span>();
</span></span><span style=display:flex><span>            ctx.<span style=color:#a6e22e>pipeline</span>().<span style=color:#a6e22e>addLast</span>(protocolHandlers);
</span></span><span style=display:flex><span>            ctx.<span style=color:#a6e22e>pipeline</span>().<span style=color:#a6e22e>remove</span>(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            in.<span style=color:#a6e22e>resetReaderIndex</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        in.<span style=color:#a6e22e>resetReaderIndex</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> preface <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[</span>in.<span style=color:#a6e22e>readableBytes</span>()<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    in.<span style=color:#a6e22e>readBytes</span>(preface);
</span></span><span style=display:flex><span>    LOGGER.<span style=color:#a6e22e>error</span>(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;Can not recognize protocol from remote {}, preface = {}&#34;</span>,
</span></span><span style=display:flex><span>            ctx.<span style=color:#a6e22e>channel</span>().<span style=color:#a6e22e>remoteAddress</span>(),
</span></span><span style=display:flex><span>            preface);
</span></span><span style=display:flex><span>    in.<span style=color:#a6e22e>clear</span>();
</span></span><span style=display:flex><span>    ctx.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ProtocolDetectHandler 在第一次对网络包进行解码时，会遍历 supportedProtocolDetectors 找到能够识别当前网络包的 ProtocolDetector，这里识别的方式是基于 ProtocolDetector.detect 方法实现的。</p><p>那么目前支持的协议有 Seata 协议、Http1.1 协议、Http2 协议，识别成功之后就会将对应的 protocolHandlers 加入到当前 Channel 的 pipeline 中，同时从 pipeline 中移除 ProtocolDetectHandler。</p><p>我们下面重点关注 SeataDetector，其返回的 ChannelHandler 为 MultiProtocolDecoder，这又是一个 ByteToMessageDecoder，其 decode 方法如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>protected</span> Object <span style=color:#a6e22e>decode</span>(ChannelHandlerContext ctx, ByteBuf in) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>    ByteBuf frame;
</span></span><span style=display:flex><span>    Object decoded;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>byte</span> version;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (isV0(in)) {
</span></span><span style=display:flex><span>            decoded <span style=color:#f92672>=</span> in;
</span></span><span style=display:flex><span>            version <span style=color:#f92672>=</span> ProtocolConstants.<span style=color:#a6e22e>VERSION_0</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 父类是 LengthFieldBasedFrameDecoder</span>
</span></span><span style=display:flex><span>            decoded <span style=color:#f92672>=</span> <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>decode</span>(ctx, in);
</span></span><span style=display:flex><span>            version <span style=color:#f92672>=</span> decideVersion(decoded);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (decoded <span style=color:#66d9ef>instanceof</span> ByteBuf) {
</span></span><span style=display:flex><span>            frame <span style=color:#f92672>=</span> (ByteBuf) decoded;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 通过 MultiProtocolDecoder 进行多版本协议识别</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 通过 version 选择对应的编解码器</span>
</span></span><span style=display:flex><span>            ProtocolDecoder decoder <span style=color:#f92672>=</span> protocolDecoderMap.<span style=color:#a6e22e>get</span>(version);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (decoder <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                LOGGER.<span style=color:#a6e22e>error</span>(
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#34;Decoder not found, version={}, use current version({})&#34;</span>,
</span></span><span style=display:flex><span>                        version,
</span></span><span style=display:flex><span>                        ProtocolConstants.<span style=color:#a6e22e>VERSION</span>);
</span></span><span style=display:flex><span>                decoder <span style=color:#f92672>=</span> protocolDecoderMap.<span style=color:#a6e22e>get</span>(ProtocolConstants.<span style=color:#a6e22e>VERSION</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            ProtocolEncoder encoder <span style=color:#f92672>=</span> protocolEncoderMap.<span style=color:#a6e22e>get</span>(version);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (encoder <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                LOGGER.<span style=color:#a6e22e>error</span>(
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#34;Encoder not found, version: {}, use current version({})&#34;</span>,
</span></span><span style=display:flex><span>                        version,
</span></span><span style=display:flex><span>                        ProtocolConstants.<span style=color:#a6e22e>VERSION</span>);
</span></span><span style=display:flex><span>                encoder <span style=color:#f92672>=</span> protocolEncoderMap.<span style=color:#a6e22e>get</span>(ProtocolConstants.<span style=color:#a6e22e>VERSION</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (decoder <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> encoder <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> UnsupportedOperationException(<span style=color:#e6db74>&#34;Unsupported version: &#34;</span> <span style=color:#f92672>+</span> version);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> decoder.<span style=color:#a6e22e>decodeFrame</span>(frame);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (version <span style=color:#f92672>!=</span> ProtocolConstants.<span style=color:#a6e22e>VERSION_0</span>) {
</span></span><span style=display:flex><span>                    frame.<span style=color:#a6e22e>release</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 添加特定版本的编解码器</span>
</span></span><span style=display:flex><span>                ctx.<span style=color:#a6e22e>pipeline</span>().<span style=color:#a6e22e>addLast</span>((ChannelHandler) decoder);
</span></span><span style=display:flex><span>                ctx.<span style=color:#a6e22e>pipeline</span>().<span style=color:#a6e22e>addLast</span>((ChannelHandler) encoder);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (channelHandlers <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    ctx.<span style=color:#a6e22e>pipeline</span>().<span style=color:#a6e22e>addLast</span>(channelHandlers);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 移除当前 MultiProtocolDecoder</span>
</span></span><span style=display:flex><span>                ctx.<span style=color:#a6e22e>pipeline</span>().<span style=color:#a6e22e>remove</span>(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Exception exx) {
</span></span><span style=display:flex><span>        LOGGER.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;Decode frame error, cause: {}&#34;</span>, exx.<span style=color:#a6e22e>getMessage</span>());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> DecodeException(exx);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> decoded;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=v1-版本协议>V1 版本协议</h3><p>Seata 的协议设计是比较周全并且通用的，也是主流的解决粘包半包问题的解决方案，即消息长度 + 消息内容。</p><p>协议的格式如下：</p><p><img src=assets/e31a6e7bddb91032bbf5881430efb4b0.png alt class=rounded-shadow-image loading=lazy></p><p>可以看到，包括魔数、协议版本号、长度域、头长度、报文类型、序列化算法、压缩算法、请求 id、可选的 map 扩展以及报文体。</p><h3 id=如何进行编解码>如何进行编解码</h3><p>Seata 解码器使用了 Netty 内置的 LengthFieldBasedFrameDecoder，不熟悉的可以看看。</p><p>不过编解码并不难，所以简单给出代码，不过多解释。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> org.apache.seata.core.rpc.netty.v1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> io.netty.buffer.ByteBuf;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> io.netty.channel.ChannelHandlerContext;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> io.netty.handler.codec.MessageToByteEncoder;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.seata.core.rpc.netty.ProtocolEncoder;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.seata.core.serializer.Serializer;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.seata.core.compressor.Compressor;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.seata.core.compressor.CompressorFactory;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.seata.core.protocol.ProtocolConstants;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.seata.core.protocol.RpcMessage;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.seata.core.serializer.SerializerServiceLoader;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.seata.core.serializer.SerializerType;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.slf4j.Logger;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.slf4j.LoggerFactory;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Map;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * &lt;pre&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 0     1     2     3     4     5     6     7     8     9    10     11    12    13    14    15    16
</span></span></span><span style=display:flex><span><span style=color:#75715e> * +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
</span></span></span><span style=display:flex><span><span style=color:#75715e> * |   magic   |proto|     full length       |    head   | Msg |Seria|Compr|      RequestId        |
</span></span></span><span style=display:flex><span><span style=color:#75715e> * |   code    |versi|     (head+body)       |   length  |Type |lizer|ess  |                       |
</span></span></span><span style=display:flex><span><span style=color:#75715e> * +-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+
</span></span></span><span style=display:flex><span><span style=color:#75715e> * |                                   Head Map [Optional]                                         |
</span></span></span><span style=display:flex><span><span style=color:#75715e> * +-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+
</span></span></span><span style=display:flex><span><span style=color:#75715e> * |                                         body                                                  |
</span></span></span><span style=display:flex><span><span style=color:#75715e> * +-----------------------------------------------------------------------------------------------+
</span></span></span><span style=display:flex><span><span style=color:#75715e> * &lt;/pre&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e> * &lt;p&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e> * &lt;li&gt;Full Length: include all data &lt;/li&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e> * &lt;li&gt;Head Length: include head data from magic code to head map. &lt;/li&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e> * &lt;li&gt;Body Length: Full Length - Head Length&lt;/li&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e> * &lt;/p&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ProtocolEncoderV1</span> <span style=color:#66d9ef>extends</span> MessageToByteEncoder <span style=color:#66d9ef>implements</span> ProtocolEncoder {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Logger LOGGER <span style=color:#f92672>=</span> LoggerFactory.<span style=color:#a6e22e>getLogger</span>(ProtocolEncoderV1.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>encode</span>(RpcMessage message, ByteBuf out) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            ProtocolRpcMessageV1 rpcMessage <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ProtocolRpcMessageV1();
</span></span><span style=display:flex><span>            rpcMessage.<span style=color:#a6e22e>rpcMsgToProtocolMsg</span>(message);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> fullLength <span style=color:#f92672>=</span> ProtocolConstants.<span style=color:#a6e22e>V1_HEAD_LENGTH</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> headLength <span style=color:#f92672>=</span> ProtocolConstants.<span style=color:#a6e22e>V1_HEAD_LENGTH</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>byte</span> messageType <span style=color:#f92672>=</span> rpcMessage.<span style=color:#a6e22e>getMessageType</span>();
</span></span><span style=display:flex><span>            out.<span style=color:#a6e22e>writeBytes</span>(ProtocolConstants.<span style=color:#a6e22e>MAGIC_CODE_BYTES</span>);
</span></span><span style=display:flex><span>            out.<span style=color:#a6e22e>writeByte</span>(ProtocolConstants.<span style=color:#a6e22e>VERSION_1</span>);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// full Length(4B) and head length(2B) will fix in the end.</span>
</span></span><span style=display:flex><span>            out.<span style=color:#a6e22e>writerIndex</span>(out.<span style=color:#a6e22e>writerIndex</span>() <span style=color:#f92672>+</span> 6); <span style=color:#75715e>// 这里跳过 full length 和 head length 的位置，最后在补</span>
</span></span><span style=display:flex><span>            out.<span style=color:#a6e22e>writeByte</span>(messageType);
</span></span><span style=display:flex><span>            out.<span style=color:#a6e22e>writeByte</span>(rpcMessage.<span style=color:#a6e22e>getCodec</span>());
</span></span><span style=display:flex><span>            out.<span style=color:#a6e22e>writeByte</span>(rpcMessage.<span style=color:#a6e22e>getCompressor</span>());
</span></span><span style=display:flex><span>            out.<span style=color:#a6e22e>writeInt</span>(rpcMessage.<span style=color:#a6e22e>getId</span>());
</span></span><span style=display:flex><span>            <span style=color:#75715e>// direct write head with zero-copy</span>
</span></span><span style=display:flex><span>            Map<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> headMap <span style=color:#f92672>=</span> rpcMessage.<span style=color:#a6e22e>getHeadMap</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (headMap <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>headMap.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> headMapBytesLength <span style=color:#f92672>=</span> HeadMapSerializer.<span style=color:#a6e22e>getInstance</span>().<span style=color:#a6e22e>encode</span>(headMap, out);
</span></span><span style=display:flex><span>                headLength <span style=color:#f92672>+=</span> headMapBytesLength;
</span></span><span style=display:flex><span>                fullLength <span style=color:#f92672>+=</span> headMapBytesLength;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> bodyBytes <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// heartbeat don&#39;t have body</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (messageType <span style=color:#f92672>!=</span> ProtocolConstants.<span style=color:#a6e22e>MSGTYPE_HEARTBEAT_REQUEST</span> <span style=color:#f92672>&amp;&amp;</span> messageType <span style=color:#f92672>!=</span> ProtocolConstants.<span style=color:#a6e22e>MSGTYPE_HEARTBEAT_RESPONSE</span>) {
</span></span><span style=display:flex><span>                Serializer serializer <span style=color:#f92672>=</span> SerializerServiceLoader.<span style=color:#a6e22e>load</span>(SerializerType.<span style=color:#a6e22e>getByCode</span>(rpcMessage.<span style=color:#a6e22e>getCodec</span>()), ProtocolConstants.<span style=color:#a6e22e>VERSION_1</span>);
</span></span><span style=display:flex><span>                bodyBytes <span style=color:#f92672>=</span> serializer.<span style=color:#a6e22e>serialize</span>(rpcMessage.<span style=color:#a6e22e>getBody</span>());
</span></span><span style=display:flex><span>                Compressor compressor <span style=color:#f92672>=</span> CompressorFactory.<span style=color:#a6e22e>getCompressor</span>(rpcMessage.<span style=color:#a6e22e>getCompressor</span>());
</span></span><span style=display:flex><span>                bodyBytes <span style=color:#f92672>=</span> compressor.<span style=color:#a6e22e>compress</span>(bodyBytes);
</span></span><span style=display:flex><span>                fullLength <span style=color:#f92672>+=</span> bodyBytes.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (bodyBytes <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                out.<span style=color:#a6e22e>writeBytes</span>(bodyBytes);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// fix fullLength and headLength</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> writeIndex <span style=color:#f92672>=</span> out.<span style=color:#a6e22e>writerIndex</span>();
</span></span><span style=display:flex><span>            <span style=color:#75715e>// skip magic code(2B) + version(1B)</span>
</span></span><span style=display:flex><span>            out.<span style=color:#a6e22e>writerIndex</span>(writeIndex <span style=color:#f92672>-</span> fullLength <span style=color:#f92672>+</span> 3);
</span></span><span style=display:flex><span>            out.<span style=color:#a6e22e>writeInt</span>(fullLength);
</span></span><span style=display:flex><span>            out.<span style=color:#a6e22e>writeShort</span>(headLength);
</span></span><span style=display:flex><span>            out.<span style=color:#a6e22e>writerIndex</span>(writeIndex);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Throwable e) {
</span></span><span style=display:flex><span>            LOGGER.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;Encode request error!&#34;</span>, e);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> e;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>encode</span>(ChannelHandlerContext ctx, Object msg, ByteBuf out) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (msg <span style=color:#66d9ef>instanceof</span> RpcMessage) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>encode</span>((RpcMessage) msg, out);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> UnsupportedOperationException(<span style=color:#e6db74>&#34;Not support this class:&#34;</span> <span style=color:#f92672>+</span> msg.<span style=color:#a6e22e>getClass</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Throwable e) {
</span></span><span style=display:flex><span>            LOGGER.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;Encode request error!&#34;</span>, e);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> org.apache.seata.core.rpc.netty.v1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.List;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Map;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> io.netty.buffer.ByteBuf;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> io.netty.channel.ChannelHandlerContext;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> io.netty.handler.codec.LengthFieldBasedFrameDecoder;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.seata.core.compressor.Compressor;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.seata.core.compressor.CompressorFactory;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.seata.core.exception.DecodeException;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.seata.core.protocol.HeartbeatMessage;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.seata.core.protocol.ProtocolConstants;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.seata.core.protocol.RpcMessage;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.seata.core.rpc.netty.ProtocolDecoder;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.seata.core.serializer.Serializer;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.seata.core.serializer.SerializerServiceLoader;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.seata.core.serializer.SerializerType;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.slf4j.Logger;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.slf4j.LoggerFactory;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * &lt;pre&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 0     1     2     3     4     5     6     7     8     9    10     11    12    13    14    15    16
</span></span></span><span style=display:flex><span><span style=color:#75715e> * +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
</span></span></span><span style=display:flex><span><span style=color:#75715e> * |   magic   |proto|     full length       |    head   | Msg |Seria|Compr|      RequestId        |
</span></span></span><span style=display:flex><span><span style=color:#75715e> * |   code    |versi|     (head+body)       |   length  |Type |lizer|ess  |                       |
</span></span></span><span style=display:flex><span><span style=color:#75715e> * +-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+
</span></span></span><span style=display:flex><span><span style=color:#75715e> * |                                   Head Map [Optional]                                         |
</span></span></span><span style=display:flex><span><span style=color:#75715e> * +-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+
</span></span></span><span style=display:flex><span><span style=color:#75715e> * |                                         body                                                  |
</span></span></span><span style=display:flex><span><span style=color:#75715e> * +-----------------------------------------------------------------------------------------------+
</span></span></span><span style=display:flex><span><span style=color:#75715e> * &lt;/pre&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e> * &lt;p&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e> * &lt;li&gt;Full Length: include all data &lt;/li&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e> * &lt;li&gt;Head Length: include head data from magic code to head map. &lt;/li&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e> * &lt;li&gt;Body Length: Full Length - Head Length&lt;/li&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e> * &lt;/p&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ProtocolDecoderV1</span> <span style=color:#66d9ef>extends</span> LengthFieldBasedFrameDecoder <span style=color:#66d9ef>implements</span> ProtocolDecoder {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Logger LOGGER <span style=color:#f92672>=</span> LoggerFactory.<span style=color:#a6e22e>getLogger</span>(ProtocolDecoderV1.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> List<span style=color:#f92672>&lt;</span>SerializerType<span style=color:#f92672>&gt;</span> supportDeSerializerTypes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>ProtocolDecoderV1</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *  int maxFrameLength,
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *  int lengthFieldOffset,  魔术 2B、版本号 1B 所以长度偏移 3B
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *  int lengthFieldLength,  FullLength is int(4B). so values is 4
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *  int lengthAdjustment,   FullLength include all data and read 7 bytes before, so the left length is (FullLength-7). so values is -7
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *  int initialBytesToStrip we will check magic code and version self, so do not strip any bytes. so values is 0
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(ProtocolConstants.<span style=color:#a6e22e>MAX_FRAME_LENGTH</span>, 3, 4, <span style=color:#f92672>-</span>7, 0);
</span></span><span style=display:flex><span>        supportDeSerializerTypes <span style=color:#f92672>=</span> SerializerServiceLoader.<span style=color:#a6e22e>getSupportedSerializers</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (supportDeSerializerTypes.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException(<span style=color:#e6db74>&#34;No serializer found&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> RpcMessage <span style=color:#a6e22e>decodeFrame</span>(ByteBuf frame) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span> b0 <span style=color:#f92672>=</span> frame.<span style=color:#a6e22e>readByte</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span> b1 <span style=color:#f92672>=</span> frame.<span style=color:#a6e22e>readByte</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (ProtocolConstants.<span style=color:#a6e22e>MAGIC_CODE_BYTES</span><span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>!=</span> b0 <span style=color:#f92672>||</span> ProtocolConstants.<span style=color:#a6e22e>MAGIC_CODE_BYTES</span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>!=</span> b1) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException(<span style=color:#e6db74>&#34;Unknown magic code: &#34;</span> <span style=color:#f92672>+</span> b0 <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>+</span> b1);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span> version <span style=color:#f92672>=</span> frame.<span style=color:#a6e22e>readByte</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> fullLength <span style=color:#f92672>=</span> frame.<span style=color:#a6e22e>readInt</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>short</span> headLength <span style=color:#f92672>=</span> frame.<span style=color:#a6e22e>readShort</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span> messageType <span style=color:#f92672>=</span> frame.<span style=color:#a6e22e>readByte</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span> codecType <span style=color:#f92672>=</span> frame.<span style=color:#a6e22e>readByte</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span> compressorType <span style=color:#f92672>=</span> frame.<span style=color:#a6e22e>readByte</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> requestId <span style=color:#f92672>=</span> frame.<span style=color:#a6e22e>readInt</span>();
</span></span><span style=display:flex><span>        ProtocolRpcMessageV1 rpcMessage <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ProtocolRpcMessageV1();
</span></span><span style=display:flex><span>        rpcMessage.<span style=color:#a6e22e>setCodec</span>(codecType);
</span></span><span style=display:flex><span>        rpcMessage.<span style=color:#a6e22e>setId</span>(requestId);
</span></span><span style=display:flex><span>        rpcMessage.<span style=color:#a6e22e>setCompressor</span>(compressorType);
</span></span><span style=display:flex><span>        rpcMessage.<span style=color:#a6e22e>setMessageType</span>(messageType);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// direct read head with zero-copy</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> headMapLength <span style=color:#f92672>=</span> headLength <span style=color:#f92672>-</span> ProtocolConstants.<span style=color:#a6e22e>V1_HEAD_LENGTH</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (headMapLength <span style=color:#f92672>&gt;</span> 0) {
</span></span><span style=display:flex><span>            Map<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> map <span style=color:#f92672>=</span> HeadMapSerializer.<span style=color:#a6e22e>getInstance</span>().<span style=color:#a6e22e>decode</span>(frame, headMapLength);
</span></span><span style=display:flex><span>            rpcMessage.<span style=color:#a6e22e>getHeadMap</span>().<span style=color:#a6e22e>putAll</span>(map);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// read body</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (messageType <span style=color:#f92672>==</span> ProtocolConstants.<span style=color:#a6e22e>MSGTYPE_HEARTBEAT_REQUEST</span>) {
</span></span><span style=display:flex><span>            rpcMessage.<span style=color:#a6e22e>setBody</span>(HeartbeatMessage.<span style=color:#a6e22e>PING</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (messageType <span style=color:#f92672>==</span> ProtocolConstants.<span style=color:#a6e22e>MSGTYPE_HEARTBEAT_RESPONSE</span>) {
</span></span><span style=display:flex><span>            rpcMessage.<span style=color:#a6e22e>setBody</span>(HeartbeatMessage.<span style=color:#a6e22e>PONG</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> bodyLength <span style=color:#f92672>=</span> fullLength <span style=color:#f92672>-</span> headLength;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (bodyLength <span style=color:#f92672>&gt;</span> 0) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> bs <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[</span>bodyLength<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>                frame.<span style=color:#a6e22e>readBytes</span>(bs);
</span></span><span style=display:flex><span>                Compressor compressor <span style=color:#f92672>=</span> CompressorFactory.<span style=color:#a6e22e>getCompressor</span>(compressorType);
</span></span><span style=display:flex><span>                bs <span style=color:#f92672>=</span> compressor.<span style=color:#a6e22e>decompress</span>(bs);
</span></span><span style=display:flex><span>                SerializerType protocolType <span style=color:#f92672>=</span> SerializerType.<span style=color:#a6e22e>getByCode</span>(rpcMessage.<span style=color:#a6e22e>getCodec</span>());
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>supportDeSerializerTypes</span>.<span style=color:#a6e22e>contains</span>(protocolType)) {
</span></span><span style=display:flex><span>                    Serializer serializer <span style=color:#f92672>=</span> SerializerServiceLoader.<span style=color:#a6e22e>load</span>(protocolType, ProtocolConstants.<span style=color:#a6e22e>VERSION_1</span>);
</span></span><span style=display:flex><span>                    rpcMessage.<span style=color:#a6e22e>setBody</span>(serializer.<span style=color:#a6e22e>deserialize</span>(bs));
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException(<span style=color:#e6db74>&#34;SerializerType not match&#34;</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> rpcMessage.<span style=color:#a6e22e>protocolMsgToRpcMsg</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> Object <span style=color:#a6e22e>decode</span>(ChannelHandlerContext ctx, ByteBuf in) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        Object decoded;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            decoded <span style=color:#f92672>=</span> <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>decode</span>(ctx, in);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (decoded <span style=color:#66d9ef>instanceof</span> ByteBuf) {
</span></span><span style=display:flex><span>                ByteBuf frame <span style=color:#f92672>=</span> (ByteBuf) decoded;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> decodeFrame(frame);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                    frame.<span style=color:#a6e22e>release</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception exx) {
</span></span><span style=display:flex><span>            LOGGER.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;Decode frame error, cause: {}&#34;</span>, exx.<span style=color:#a6e22e>getMessage</span>());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> DecodeException(exx);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> decoded;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><div class="row middle-xs"><div class=col-xs-12></div></div><div class=row><div class=col-xs-12></div></div><div style=height:50px></div><div class=post-comments><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://hein-hp-click.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div><div class=site-footer><div class=footer-content><div class=footer-copyright>Copyright He Jin © 2025</div><div class=footer-separator>|</div><div class=footer-license><a href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank rel=noopener>CC BY-NC-ND 4.0</a></div></div></div></div></div></article><a href=# class=back-to-top id=backToTop title=返回顶部></a><div class=toc-trigger id=tocTrigger></div><script>document.addEventListener("DOMContentLoaded",function(){const e=document.getElementById("backToTop");e&&(window.addEventListener("scroll",function(){window.pageYOffset>300?e.classList.add("show"):e.classList.remove("show")}),e.addEventListener("click",function(e){e.preventDefault(),window.scrollTo({top:0,behavior:"smooth"})}))});function wrapTables(){const e=document.querySelectorAll(".markdown-body table");e.forEach(function(e){if(!e.parentElement.classList.contains("table-container")){const t=document.createElement("div");t.className="table-container",e.parentNode.insertBefore(t,e),t.appendChild(e)}})}wrapTables();function initTableOfContents(){const e=document.getElementById("tocContainer"),t=document.getElementById("tocContent"),n=document.getElementById("tocTrigger");if(!e||!t)return;const s=document.querySelectorAll(".markdown-body h1, .markdown-body h2, .markdown-body h3");if(s.length===0){e.style.display="none",n&&(n.style.display="none");return}s.forEach((e,t)=>{e.id||(e.id=`heading-${t}`)});let i="<ul>";s.forEach((e)=>{const s=e.tagName.toLowerCase(),o=e.textContent.trim(),n=e.id;i+=`<li class="toc-${s}">
        <a href="#${n}" data-target="${n}">${o}</a>
      </li>`}),i+="</ul>",t.innerHTML=i;let r=!1,a;function c(){clearTimeout(a),e.classList.add("show"),r=!0}function l(){a=setTimeout(()=>{e.classList.remove("show"),r=!1},300)}n&&(n.addEventListener("mouseenter",c),n.addEventListener("mouseleave",l)),e.addEventListener("mouseenter",()=>{clearTimeout(a),c()}),e.addEventListener("mouseleave",l),t.addEventListener("click",e=>{if(e.target.tagName==="A"){e.preventDefault();const n=e.target.getAttribute("data-target"),t=document.getElementById(n);if(t){const e=t.offsetTop-80;window.scrollTo({top:e,behavior:"smooth"})}}});let o=null;function d(){const n=window.pageYOffset;let e=null;for(let t=s.length-1;t>=0;t--){const o=s[t];if(o.offsetTop-100<=n){e=o;break}}if(e){const n=t.querySelector(`a[data-target="${e.id}"]`);if(n!==o&&(o&&o.classList.remove("active"),n)){n.classList.add("active"),o=n;const e=t.getBoundingClientRect(),s=n.getBoundingClientRect();(s.top<e.top||s.bottom>e.bottom)&&n.scrollIntoView({behavior:"smooth",block:"center"})}}}let u;window.addEventListener("scroll",()=>{clearTimeout(u),u=setTimeout(d,50)}),d()}initTableOfContents()</script></body></html>